#!/usr/bin/env python3
import rclpy
import math
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped, Point, Twist
from std_msgs.msg import Bool
from collections import deque
from sensor_msgs.msg import LaserScan
from pinky_controller.goal_points import GOAL_PATHS, FINAL_YAWS_DEG

# ===== 사용자 설정값 =====
YAW_THRESHOLD_DEG    = 7.0
ROTATE_SPEED_DEG     = 0.1
LINEAR_SPEED         = 0.1
GOAL_TOLERANCE       = 0.1

# ---- 라이다 관련 (필수 조정 포인트) ----
FRONT_FOV_DEG        = 60.0     # 원하는 총 스캔 폭(앞 기준 ±30°)
LIDAR_YAW_OFFSET_DEG = 180.0    # ★ 기준 폭에서 앞을 정확히 가리킨 중심각
FRONT_FOV_BASE_DEG   = 10.0     # ★ 과거 '앞'을 맞췄던 기준 폭(예: 10°에서 180°가 앞)
MIN_OBS_DIST_ON      = 0.25     # 장애물 감지(ON) 임계거리
MIN_OBS_DIST_OFF     = 0.75     # 장애물 해제(OFF) 임계거리(ON보다 크게)
USE_PCTL             = True     # 최솟값 대신 하위 백분위수 사용
PCTL                 = 20       # 하위 20% 지점

# ---- 회피 파라미터 ----
# 회피 직진 3구간 각각의 거리 (요청사항)
AVOID_FORWARD_DIST_1 = 0.15     # R45 후 1차 전진
AVOID_FORWARD_DIST_2 = 0.15     # L45 후 2차 전진
AVOID_FORWARD_DIST_3 = 0.15     # 두 번째 L45 후 마지막 전진
PULSE_ON_SEC         = 0.15     # 펄스 회전 on 시간
PULSE_RESET_SEC      = 0.20     # 펄스 타이머 리셋 간격

# ===== 좌표 기반 회피 ON/OFF 지점 =====
ENABLE_POINTS  = [
    # (0.11, 0.88, 0.15),
]
DISABLE_POINTS = [
    (0.54, 0.8, 0.15),
]

# 라디안 변환
YAW_THRESHOLD = math.radians(YAW_THRESHOLD_DEG)
ROTATE_SPEED  = math.radians(ROTATE_SPEED_DEG)

def normalize_angle(angle):
    while angle > math.pi:
        angle -= 2.0 * math.pi
    while angle < -math.pi:
        angle += 2.0 * math.pi
    return angle

class _CircleGate:
    """원 경계 바깥→안쪽으로 진입할 때 한 번만 True를 반환"""
    def __init__(self, x, y, r):
        self.x = float(x); self.y = float(y); self.r = float(r)
        self.prev_outside = True
    def update_and_fired(self, px, py):
        dx = px - self.x; dy = py - self.y
        inside = (dx*dx + dy*dy) <= (self.r * self.r)
        fired = (self.prev_outside and inside)
        self.prev_outside = (not inside)
        return fired

class ControllerNode(Node):
    def __init__(self):
        super().__init__('controller_node')

        # 로봇 상태
        self.robot_pose = None
        self.robot_yaw = None
        self.raw_yaw = None
        self.goal_pose = None
        self.state = 'IDLE'
        self.auto_start = False
        self.last_pulse_time = self.get_clock().now()

        # 목표 큐
        self.goal_queue = deque()
        self.final_target_yaw = -0.5 * math.pi  # 기본 -90도

        # 파라미터
        marker_id = self.declare_parameter('marker_id', 26).get_parameter_value().integer_value
        topic_name = f"marker_map/ID{marker_id}"

        # 구독/퍼블리셔
        self.create_subscription(PoseStamped, topic_name, self.robot_callback, 10)
        self.cmd_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        self.timer = self.create_timer(0.15, self.control_loop)

        self.create_subscription(Bool, 'go_to_kitchen', lambda msg: self.load_path('kitchen', msg), 10)
        self.create_subscription(Bool, 'go_to_serving', lambda msg: self.load_path('serving', msg), 10)
        self.create_subscription(Bool, 'go_to_charge',  lambda msg: self.load_path('charge', msg), 10)
        self.create_subscription(Bool, 'go_to_room',    lambda msg: self.load_path('room', msg), 10)
        self.create_subscription(Bool, 'go_to_recall',  lambda msg: self.load_path('recall', msg), 10)
        self.create_subscription(Bool, 'go_to_return',  lambda msg: self.load_path('return', msg), 10)
        self.create_subscription(Bool, 'stop', self.cb_stop, 10)  # ✅ STOP 구독

        # 라이다
        self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        self.front_blocked = False

        # 회피 상태
        self.avoid_target_yaw = None
        self.avoid_start_pos = None

        # 회피 ON/OFF 게이트
        self.obstacle_enabled = True
        self.enable_gates  = [_CircleGate(*p) for p in ENABLE_POINTS]
        self.disable_gates = [_CircleGate(*p) for p in DISABLE_POINTS]

        self.get_logger().info("[INIT] controller_node 초기화 완료. 명령 토픽을 대기 중.")

    # ---------- 경로 로드/전환 ----------
    def load_path(self, path_name, msg):
        if msg.data:
            if path_name in GOAL_PATHS:
                self.goal_queue.clear()
                for x, y in GOAL_PATHS[path_name]:
                    pt = Point(); pt.x, pt.y, pt.z = x, y, 0.0
                    self.goal_queue.append(pt)
                final_deg = FINAL_YAWS_DEG.get(path_name, -90.0)
                self.final_target_yaw = math.radians(final_deg)
                self.auto_start = True
                self.set_next_goal()
                self.get_logger().info(
                    f"[ROUTE] '{path_name}' 시작 "
                    f"(총 {len(self.goal_queue)+1 if self.goal_pose else len(self.goal_queue)}개 좌표, 최종각 {final_deg:.1f}°)"
                )
            else:
                self.get_logger().warn(f"[ERROR] '{path_name}' 경로가 존재하지 않음")

    def set_next_goal(self):
        if self.goal_queue:
            self.goal_pose = self.goal_queue.popleft()
            self.state = 'ROTATE'
            self.last_pulse_time = self.get_clock().now()
            self.get_logger().info(f"[GOAL] 다음 목표: x={self.goal_pose.x:.2f}, y={self.goal_pose.y:.2f}")
        else:
            self.goal_pose = None
            self.state = 'IDLE'
            self.auto_start = False
            self.get_logger().info("[GOAL] 모든 목표 완료. 대기 상태로 전환.")

    # ---------- 상태 업데이트 ----------
    def robot_callback(self, msg):
        self.robot_pose = msg.pose.position
        q = msg.pose.orientation
        siny = 2.0 * (q.w * q.z + q.x * q.y)
        cosy = 1.0 - 2.0 * (q.y**2 + q.z**2)
        self.raw_yaw = math.atan2(siny, cosy)
        self.robot_yaw = self.raw_yaw

        if self.robot_pose is not None:
            px, py = self.robot_pose.x, self.robot_pose.y
            for gate in self.disable_gates:
                if gate.update_and_fired(px, py):
                    if self.obstacle_enabled:
                        self.obstacle_enabled = False
                        self.front_blocked = False
                        self.get_logger().warn("장애물 인식 비활성화됨!")
            for gate in self.enable_gates:
                if gate.update_and_fired(px, py):
                    if not self.obstacle_enabled:
                        self.obstacle_enabled = True
                        self.get_logger().info("장애물 인식 활성화됨!")

    # ---------- 라이다 ----------
    def scan_callback(self, scan: LaserScan):
        if not getattr(self, 'obstacle_enabled', True):
            return
        try:
            if not scan.ranges:
                return

            # === 스캔 창 계산 ===
            # 1) 기준 폭(FRONT_FOV_BASE_DEG)에서 맞춰둔 '앞' 중심(LIDAR_YAW_OFFSET_DEG)을 유지
            # 2) 원하는 새 폭(FRONT_FOV_DEG)에 대해, 같은 '앞'을 중앙으로 갖도록 보정
            #    → effective_center_deg = LIDAR_YAW_OFFSET_DEG + (FRONT_FOV_BASE_DEG - FRONT_FOV_DEG) / 2
            # 3) 중앙은 고정하고(가능한 한), 센서 범위를 넘으면 폭만 줄여 '대칭' 유지
            desired_half = math.radians(FRONT_FOV_DEG * 0.5)
            effective_center_deg = LIDAR_YAW_OFFSET_DEG + 0.5 * (FRONT_FOV_BASE_DEG - FRONT_FOV_DEG)
            center = math.radians(effective_center_deg)

            ang_min, ang_max, inc = scan.angle_min, scan.angle_max, scan.angle_increment

            # 센서 범위 안에서 유지 가능한 최대 절반폭(대칭)
            max_half_allowed = min(center - ang_min, ang_max - center)
            if max_half_allowed <= 0.0:
                # 중앙이 센서 범위 밖이면 사용할 수 없음
                return

            half = min(desired_half, max_half_allowed)

            from_ang = center - half
            to_ang   = center + half
            if to_ang <= from_ang:
                return

            i_from = max(0, int((from_ang - ang_min) / inc))
            i_to   = min(len(scan.ranges) - 1, int((to_ang   - ang_min) / inc))

            window = []
            rmax = scan.range_max if math.isfinite(scan.range_max) and scan.range_max > 0.0 else float('inf')
            for r in scan.ranges[i_from:i_to+1]:
                if math.isfinite(r) and 0.01 < r < rmax:
                    window.append(r)
            if not window:
                return

            if USE_PCTL:
                window.sort()
                k = max(0, min(len(window)-1, int(len(window)*PCTL/100.0)))
                front_near = window[k]
            else:
                front_near = min(window)

            if not self.front_blocked and front_near < MIN_OBS_DIST_ON:
                self.front_blocked = True
                self.get_logger().info(f"[LIDAR] 전방 차단 감지: ≈{front_near:.2f} m (ON<{MIN_OBS_DIST_ON}m)")
            elif self.front_blocked and front_near > MIN_OBS_DIST_OFF:
                self.front_blocked = False
                self.get_logger().info(f"[LIDAR] 전방 차단 해제: ≈{front_near:.2f} m (OFF>{MIN_OBS_DIST_OFF}m)")

        except Exception as e:
            self.get_logger().warn(f"[LIDAR] 예외: {e}")

    # ---------- 제어 루프 ----------
    def control_loop(self):
        if not self.auto_start:
            return
        if self.robot_pose is None or self.robot_yaw is None or self.goal_pose is None:
            return

        dx = self.goal_pose.x - self.robot_pose.x
        dy = self.goal_pose.y - self.robot_pose.y
        target_yaw = math.atan2(dy, dx) - 0.5 * math.pi
        yaw_err = normalize_angle(target_yaw - self.robot_yaw)
        yaw_err_deg = math.degrees(yaw_err)
        distance = math.hypot(dx, dy)

        cmd = Twist()

        # [SAFETY] 전방 차단 시 회피 시퀀스 진입(중복 진입 방지)
        if getattr(self, 'obstacle_enabled', True) and self.front_blocked and self.state not in (
            'AVOID_TURN_RIGHT', 'AVOID_FORWARD', 'AVOID_TURN_LEFT',
            'AVOID_FORWARD_2', 'AVOID_TURN_LEFT_2', 'AVOID_FORWARD_3'
        ):
            self.cmd_pub.publish(Twist())  # 즉시 정지
            # 1) 오른쪽 45°
            self.avoid_target_yaw = normalize_angle(self.robot_yaw - math.pi/4.0)
            self.avoid_start_pos = None
            self.state = 'AVOID_TURN_RIGHT'
            self.last_pulse_time = self.get_clock().now()
            self.get_logger().warn("[SAFETY] 장애물 감지 → 정지 & 회피 시작 (오른쪽 45°)")
            return

        # ➊ 최종 정렬
        if self.state == 'FINAL_ALIGN':
            target_yaw_final = self.final_target_yaw
            yaw_err2 = normalize_angle(target_yaw_final - self.robot_yaw)
            if abs(yaw_err2) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                self.get_logger().info("[STATE] FINAL_ALIGN 완료 → IDLE")
                self.state = 'IDLE'
                self.auto_start = False
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.linear.x = 0.0
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err2) if t < PULSE_ON_SEC else 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.get_logger().info(f"[FINAL_ALIGN] 정렬 중 | yaw_err={math.degrees(yaw_err2):.2f}° → 목표 {math.degrees(target_yaw_final):.2f}°")
            self.cmd_pub.publish(cmd)
            return

        # ➋ 목표 도달
        if distance < GOAL_TOLERANCE:
            self.cmd_pub.publish(Twist())
            if self.goal_queue:
                self.get_logger().info(f"[DONE] 중간 목표 도착 (±{GOAL_TOLERANCE}m). 다음 좌표로 이동.")
                self.set_next_goal()
                return
            else:
                self.get_logger().info("[DONE] 최종 목표 도착. 최종 각도 정렬 시작.")
                self.state = 'FINAL_ALIGN'
                self.last_pulse_time = self.get_clock().now()
                return

        # ➌ 일반 FSM
        if self.state == 'ROTATE':
            if abs(yaw_err) < YAW_THRESHOLD:
                self.get_logger().info(f"[STATE] ROTATE → FORWARD | yaw 오차 {yaw_err_deg:.2f}° < {YAW_THRESHOLD_DEG}°")
                self.state = 'FORWARD'
                cmd.linear.x = LINEAR_SPEED
                self.cmd_pub.publish(cmd)
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.get_logger().info(f"[ROTATE] 회전 중 | yaw_err={yaw_err_deg:.2f}°")
            self.cmd_pub.publish(cmd)

        elif self.state == 'FORWARD':
            cmd.linear.x = LINEAR_SPEED
            if abs(yaw_err) > YAW_THRESHOLD:
                self.get_logger().info(f"[STATE] FORWARD → ROTATE | yaw 오차 {yaw_err_deg:.2f}° > {YAW_THRESHOLD_DEG}°")
                self.state = 'ROTATE'
                self.cmd_pub.publish(cmd)
                return
            cmd.angular.z = 0.0
            self.get_logger().info(f"[FORWARD] 전진 중 | 거리={distance:.2f} m, yaw_err={yaw_err_deg:.2f}°")
            self.cmd_pub.publish(cmd)

        # ➍ 회피 시퀀스 (→R90 →F1 →L90 →F2 →L90 →F3)
        elif self.state == 'AVOID_TURN_RIGHT':
            yaw_err_r = normalize_angle(self.avoid_target_yaw - self.robot_yaw)
            if abs(yaw_err_r) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                # 2) 직진(구간1)
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
                self.state = 'AVOID_FORWARD'
                self.get_logger().info(f"[AVOID] 오른쪽 45° 완료 → 전진 {AVOID_FORWARD_DIST_1:.2f} m")
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err_r) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_FORWARD':
            if self.avoid_start_pos is None:
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
            moved = math.hypot(self.robot_pose.x - self.avoid_start_pos[0],
                               self.robot_pose.y - self.avoid_start_pos[1])
            if moved >= AVOID_FORWARD_DIST_1:
                self.cmd_pub.publish(Twist())
                # 3) 왼쪽 45°
                self.avoid_target_yaw = normalize_angle(self.robot_yaw + math.pi/4.0)
                self.state = 'AVOID_TURN_LEFT'
                self.last_pulse_time = self.get_clock().now()
                self.get_logger().info("[AVOID] 1차 전진 완료 → 왼쪽 40°")
                return
            cmd.linear.x = LINEAR_SPEED
            cmd.angular.z = 0.0
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_TURN_LEFT':
            yaw_err_l = normalize_angle(self.avoid_target_yaw - self.robot_yaw)
            if abs(yaw_err_l) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                # 4) 직진(구간2)
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
                self.state = 'AVOID_FORWARD_2'
                self.get_logger().info(f"[AVOID] 왼쪽 90° 완료 → 전진 {AVOID_FORWARD_DIST_2:.2f} m")
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err_l) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_FORWARD_2':
            if self.avoid_start_pos is None:
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
            moved = math.hypot(self.robot_pose.x - self.avoid_start_pos[0],
                               self.robot_pose.y - self.avoid_start_pos[1])
            if moved >= AVOID_FORWARD_DIST_2:
                self.cmd_pub.publish(Twist())
                # 5) 왼쪽 45°
                self.avoid_target_yaw = normalize_angle(self.robot_yaw + math.pi/4.5)
                self.state = 'AVOID_TURN_LEFT_2'
                self.last_pulse_time = self.get_clock().now()
                self.get_logger().info("[AVOID] 2차 전진 완료 → 다시 왼쪽 90°")
                return
            cmd.linear.x = LINEAR_SPEED
            cmd.angular.z = 0.0
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_TURN_LEFT_2':
            yaw_err_l2 = normalize_angle(self.avoid_target_yaw - self.robot_yaw)
            if abs(yaw_err_l2) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                # 6) 마지막 직진(구간3)
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
                self.state = 'AVOID_FORWARD_3'
                self.get_logger().info(f"[AVOID] 두 번째 왼쪽 90° 완료 → 마지막 전진 {AVOID_FORWARD_DIST_3:.2f} m")
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err_l2) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_FORWARD_3':
            if self.avoid_start_pos is None:
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
            moved = math.hypot(self.robot_pose.x - self.avoid_start_pos[0],
                               self.robot_pose.y - self.avoid_start_pos[1])
            if moved >= AVOID_FORWARD_DIST_3:
                self.cmd_pub.publish(Twist())
                # 7) 회피 종료 → 원래 경로 복귀(ROTATE)
                self.state = 'ROTATE'
                self.get_logger().info("[AVOID] 마지막 전진 완료 → 경로 복귀(ROTATE)")
                return
            cmd.linear.x = LINEAR_SPEED
            cmd.angular.z = 0.0
            self.cmd_pub.publish(cmd)

    # ---------- ✅ STOP 콜백 ----------
    def cb_stop(self, msg: Bool):
        if not msg.data:
            return
        # 즉시 정지
        try:
            self.cmd_pub.publish(Twist())
        except Exception:
            pass
        # 상태 리셋
        self.auto_start = False
        self.state = 'IDLE'
        self.goal_queue.clear()
        self.goal_pose = None
        self.avoid_target_yaw = None
        self.avoid_start_pos = None
        self.front_blocked = False
        self.get_logger().warn("[STOP] 수신 → 즉시 정지 및 IDLE 전환")

def main(args=None):
    rclpy.init(args=args)
    node = ControllerNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
