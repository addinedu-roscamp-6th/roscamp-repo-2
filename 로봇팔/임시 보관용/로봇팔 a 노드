# import rclpy
# from rclpy.node import Node
# from std_msgs.msg import Int32, Bool
# import time

# from pymycobot.mycobot280 import MyCobot280

# class RobotA1Node(Node):
#     def __init__(self):
#         super().__init__('robot_a1_node')

#         # MyCobot Ïó∞Í≤∞
#         self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
#         self.mc.thread_lock = True
#         self.get_logger().info("ü§ñ JetCobot A Ïó∞Í≤∞ ÏôÑÎ£å")

#         # ‚úÖ ÌçºÎ∏îÎ¶¨ÏÖî Î∞è ÏÑúÎ∏åÏä§ÌÅ¨ÎùºÏù¥Î≤Ñ ÏÉùÏÑ±
#         self.ready_pub = self.create_publisher(Bool, '/a_1_ready', 10)
#         self.done_pub = self.create_publisher(Bool, '/a_1_done', 10)
#         self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, 10)

#         # ‚úÖ Ï§ÄÎπÑ Ïã†Ìò∏ Î∞òÎ≥µ Î∞úÌñâ (0.5Ï¥àÎßàÎã§)
#         self.create_timer(0.5, self.publish_ready)

#         # ‚úÖ ÏôÑÎ£å Ïã†Ìò∏ Ïû¨Î∞úÌñâÏùÑ ÏúÑÌïú ÌÉÄÏù¥Î®∏ (0.1Ï¥àÎßàÎã§)
#         self.create_timer(0.1, self.publish_done_if_needed)

#         # ‚úÖ ÎèôÏûë Ïû¨Ïã§Ìñâ Í∞êÏãú ÌÉÄÏù¥Î®∏ (2Ï¥àÎßàÎã§)
#         self.create_timer(2.0, self.check_step_timeout)

#         # ‚úÖ Ï¥àÍ∏∞ ÏÉÅÌÉú
#         self.step_done = False
#         self.executing_step = None
#         self.last_step_time = None

#         # ‚úÖ Ï¥àÍ∏∞Ìôî
#         self.mc.send_angles([0, 0, 0, 0, 0, 0], 30)
#         self.mc.set_gripper_value(100, 30)
#         time.sleep(2)
#         self.get_logger().info("üîÑ Ï§ÄÎπÑ ÏûêÏÑ∏ ÏôÑÎ£å")

#         self.ready_log_printed = False

#         # ‚úÖ ÎèôÏûë ÌÖåÏù¥Î∏î
#         self.action_map = {
#             101: [-30, 0, -70, -20, 0, 45, 100],
#             102: [0, 0, -150, 60, -60, 45, 100],
#             103: [0, 0, -150, 60, 0, 45, 0],
#             104: [0, 0, -40, -45, 0, 45, 0],
#             105: [0, -55, -47, 11, 0, 45, 0],
#             106: [0, -55, -47, 11, 0, 45, 100],
#             107: [0, 0, -40, -45, 0, 45, 0],
#             108: [0, 0, -150, 60, -60, 45, 100],
#             109: [0, 0, -150, 60, 0, 45, 0],
#             110: [0, 0, -40, -45, 0, 45, 0],
#             111: [0, -47, -48, 8, 0, 45, 100],
#             112: [-30, 0, -70, -20, 0, 45, 100],


#             201: [-30, 0, -70, -20, 0, 45, 100],    # Ï¥àÍ∏∞
#             202: [0, -47, -48, 8, -60, 45, 100],    # ÏãùÌåê1 ÏúÑÏπò
#             203: [0, -47, -48, 8, 0, 45, 0],        # ÏãùÌåê1 Ïû°Í∏∞
#             204: [0, 0, -40, -45, 0, 45, 0],        # ÏãùÌåê Îì§Í∏∞
#             205: [0, 0, -150, 60, 0, 45, 0],        # ÏãùÌåê ÎÜìÍ∏∞
#             206: [-168, -50, -60, 20, 0, 55, 0],    # ÌöåÏ†Ñ
#             207: [-168, -50, -60, 20, 0, 55, 100], # Î≤ÑÎ¶¨Í∏∞
#             208: [0, 0, 0, -90, 0, 45, 100],        # Ï¥àÍ∏∞2
#             209: [0, -55, -47, 11, -60, 45, 100],   # ÏãùÌåê2 ÏúÑÏπò
#             210: [0, -55, -47, 11, 0, 45, 0],       # ÏãùÌåê2 Ïû°Í∏∞
#             211: [0, 0, -40, -45, 0, 45, 0],        # Îì§Í∏∞
#             212: [0, 0, -150, 60, 0, 45, 0],        # ÎÜìÍ∏∞
#             213: [-168, -50, -60, 20, 0, 55, 0],    # ÌöåÏ†Ñ
#             214: [-168, -50, -60, 20, 0, 55, 100], # Î≤ÑÎ¶¨Í∏∞
#             215: [-30, 0, -70, -20, 0, 45, 100],    # Ï¥àÍ∏∞
#         }

#     def publish_ready(self):
#         if not self.ready_log_printed:
#             self.get_logger().info("üì° Ï§ÄÎπÑ Ïã†Ìò∏ Î∞úÌñâ (/a_1_ready)")
#             self.ready_log_printed = True  # ‚úÖ Ïù¥ÌõÑÎ∂ÄÌÑ∞ Ï∂úÎ†•ÌïòÏßÄ ÏïäÏùå
#         self.ready_pub.publish(Bool(data=True))


#     def step_callback(self, msg):
#         step = msg.data
#         if step == self.executing_step:
#             # ÎèôÏùºÌïú step Ïû¨ÏàòÏã† Ïãú Î¨¥Ïãú
#             return

#         self.executing_step = step
#         self.last_step_time = time.time()

#         if step in self.action_map:
#             angles = self.action_map[step]
#             self.get_logger().info(f"‚ñ∂Ô∏è [A-1] Step {step} ÎèôÏûë Ïã§Ìñâ: {angles}")
#             try:
#                 self.mc.send_angles(angles[:6], 30)
#                 self.mc.set_gripper_value(angles[6], 30)
#                 time.sleep(2)
#                 self.get_logger().info(f"‚úÖ [A-1] Step {step} ÏôÑÎ£å")
#                 self.step_done = True
#             except Exception as e:
#                 self.get_logger().error(f"‚ùå Step {step} Ïã§Ìå®: {e}")
#         else:
#             self.get_logger().warn(f"‚ö†Ô∏è Step {step}ÏùÄ AÍ∞Ä ÏàòÌñâÌï† Ïàò ÏóÜÏùå")
#             self.step_done = True

#     def publish_done_if_needed(self):
#         if self.step_done:
#             self.done_pub.publish(Bool(data=True))
#             self.get_logger().info("üì§ ÏôÑÎ£å Ïã†Ìò∏ Ï†ÑÏÜ° (/a_1_done)")
#             self.step_done = False
#             self.executing_step = None
#             self.last_step_time = None

#     def check_step_timeout(self):
#         if self.executing_step is not None and self.last_step_time is not None:
#             elapsed = time.time() - self.last_step_time
#             if elapsed > 5.0:
#                 self.get_logger().warn(f"‚è±Ô∏è Step {self.executing_step} ÌÉÄÏûÑÏïÑÏõÉ Î∞úÏÉù ‚Üí Í∞ïÏ†ú Ïû¨Ïã§Ìñâ")
#                 # Ïû¨Ïã§Ìñâ ÏãúÎèÑ
#                 self.step_callback(Int32(data=self.executing_step))  # Ïû¨Ï†ÑÏÜ°

# def main(args=None):
#     rclpy.init(args=args)
#     node = RobotA1Node()
#     try:
#         rclpy.spin(node)
#     except KeyboardInterrupt:
#         pass
#     node.destroy_node()
#     rclpy.shutdown()

# if __name__ == '__main__':
#     main()



# ###########################




# # # ‚úÖ ÏµúÏ¢Ö ÌÜµÌï©: robot_a1_node.py
# # # - Í∏∞Ï°¥ ÏΩîÎìú2Ïùò step Í∏∞Î∞ò Íµ¨Ï°∞ Ïú†ÏßÄ
# # # - step == 999ÏóêÏÑúÎßå 1Î≤à Í∏∞Îä•(ÎßàÏª§ Ï§ëÏã¨ Ï∂îÏ†Å)
# # # - calibration.json Î≥¥Ï†ïÍ∞í ÏÇ¨Ïö©
# # # - Flask Ïä§Ìä∏Î¶¨Î∞ç Ìè¨Ìï® (http://<ip>:9816)
# # # - ArUco ÎßàÏª§ Ïù∏Ïãù Î∞è Ï¢åÌëúÍ≥Ñ ÏãúÍ∞ÅÌôî

# # import rclpy
# # from rclpy.node import Node
# # from std_msgs.msg import Int32, Bool
# # import time, threading, socket, signal, sys, atexit, os, json, cv2, numpy as np
# # import cv2.aruco as aruco
# # from flask import Flask, Response
# # from pymycobot.mycobot280 import MyCobot280

# # # === Î≥¥Ï†ïÍ∞í Î°úÎî© ===
# # CAL_FILE = 'calibration.json'
# # DEFAULT_DT = [33.406, 19.536, 246.961]
# # if os.path.exists(CAL_FILE):
# #     try:
# #         with open(CAL_FILE) as f:
# #             DT = np.array(json.load(f)['T_CAM2BASE_STATIC'], float)
# #     except (KeyError, json.JSONDecodeError):
# #         print("‚ö†Ô∏è 'T_CAM2BASE_STATIC' ÎàÑÎùΩ ‚Üí Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
# #         DT = np.array(DEFAULT_DT, float)
# # else:
# #     DT = np.array(DEFAULT_DT, float)

# # # === ÎßàÏª§ / Ïπ¥Î©îÎùº ÏÑ§Ï†ï ===
# # MARKER_LEN = 35.0
# # T_TOOL2CAM = np.array([0, 0, 0.0])
# # CAM_MTX = np.array([[2736.98231, 0.0, 320.553729],
# #                     [0.0, 2730.38853, 234.335302],
# #                     [0.0, 0.0, 1.0]])
# # DIST_COEFFS = np.array([[-2.09578526, -43.8402559, -0.0176765795, -0.0463219652, 511.115001]])
# # ARUCO_DICT = aruco.getPredefinedDictionary(aruco.DICT_5X5_50)
# # ARUCO_PARAMS = aruco.DetectorParameters()

# # FAST_SPEED = 50
# # SLOW_SPEED = 12
# # BLEND_MODE = 1

# # app = Flask(__name__)
# # cap = None
# # latest_frame = None
# # lock = threading.Lock()


# # def stream_cam():
# #     global cap, latest_frame
# #     while True:
# #         if cap is None or not cap.isOpened():
# #             cap = cv2.VideoCapture(0)
# #             if not cap.isOpened():
# #                 time.sleep(1)
# #                 continue
# #         ret, fr = cap.read()
# #         if not ret:
# #             time.sleep(0.1)
# #             continue
# #         with lock:
# #             latest_frame = fr
# #         time.sleep(0.03)

# # @app.route('/')
# # def index():
# #     return "<h1>JetCobot A1</h1><img src='/video_feed'>"

# # @app.route('/video_feed')
# # def video_feed():
# #     def gen():
# #         while True:
# #             with lock:
# #                 fr = latest_frame.copy() if latest_frame is not None else None
# #             if fr is None:
# #                 time.sleep(0.03)
# #                 continue
# #             gray = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)
# #             corners, ids, _ = aruco.detectMarkers(gray, ARUCO_DICT, parameters=ARUCO_PARAMS)
# #             if ids is not None:
# #                 aruco.drawDetectedMarkers(fr, corners, ids)
# #                 objp = np.array([[-MARKER_LEN/2, MARKER_LEN/2, 0], [ MARKER_LEN/2, MARKER_LEN/2, 0],
# #                                  [ MARKER_LEN/2,-MARKER_LEN/2, 0], [-MARKER_LEN/2,-MARKER_LEN/2, 0]], np.float32)
# #                 imgp = corners[0].reshape(-1, 2).astype(np.float32)
# #                 success, rvec, tvec = cv2.solvePnP(objp, imgp, CAM_MTX, DIST_COEFFS)
# #                 if success:
# #                     cv2.drawFrameAxes(fr, CAM_MTX, DIST_COEFFS, rvec, tvec, 10)
# #             ret, jpeg = cv2.imencode('.jpg', fr)
# #             if ret:
# #                 yield (b'--frame\r\nContent-Type:image/jpeg\r\n\r\n' + jpeg.tobytes() + b'\r\n')
# #             time.sleep(0.03)
# #     return Response(gen(), mimetype='multipart/x-mixed-replace; boundary=frame')

# # def euler_to_R(rx, ry, rz):
# #     a, b, c = np.deg2rad([rx, ry, rz])
# #     Rz = np.array([[np.cos(c), -np.sin(c), 0], [np.sin(c), np.cos(c), 0], [0, 0, 1]])
# #     Ry = np.array([[np.cos(b), 0, np.sin(b)], [0, 1, 0], [-np.sin(b), 0, np.cos(b)]])
# #     Rx = np.array([[1, 0, 0], [0, np.cos(a), -np.sin(a)], [0, np.sin(a), np.cos(a)]])
# #     return Rz @ Ry @ Rx

# # class RobotA1Node(Node):
# #     def __init__(self):
# #         super().__init__('robot_a1_node')
# #         self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
# #         self.mc.thread_lock = True
# #         self.get_logger().info("ü§ñ JetCobot A Ïó∞Í≤∞ ÏôÑÎ£å")

# #         self.ready_pub = self.create_publisher(Bool, '/a_1_ready', 10)
# #         self.done_pub = self.create_publisher(Bool, '/a_1_done', 10)
# #         self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, 10)
# #         self.create_timer(0.5, self.publish_ready)
# #         self.create_timer(0.1, self.publish_done_if_needed)
# #         self.create_timer(2.0, self.check_step_timeout)

# #         self.step_done = False
# #         self.executing_step = None
# #         self.last_step_time = None

# #         self.mc.send_angles([0]*6, 30)
# #         self.mc.set_gripper_value(100, 30)
# #         time.sleep(2)
# #         self.get_logger().info("üîÑ Ï§ÄÎπÑ ÏûêÏÑ∏ ÏôÑÎ£å")

# #         self.ready_log_printed = False

# #         self.action_map = {
# #             101: [-30, 0, -70, -20, 0, 45, 100],

# #             #Ïó¨Í∏∞Í∞Ä ÎßàÏª§ Ïù∏ÏãùÏúºÎ°ú Ìï¥ÏÑú Í∞ÄÏïºÌï† Í≤É

# #             102: [0, 0, -150, 60, -60, 45, 100],
# #             103: [0, 0, -150, 60, 0, 45, 0],
# #             104: [0, 0, -40, -45, 0, 45, 0],
# #             105: [0, -55, -47, 11, 0, 45, 0],
# #             106: [0, -55, -47, 11, 0, 45, 100],
# #             107: [0, 0, -40, -45, 0, 45, 0],
# #             108: [0, 0, -150, 60, -60, 45, 100],
# #             109: [0, 0, -150, 60, 0, 45, 0],
# #             110: [0, 0, -40, -45, 0, 45, 0],
# #             111: [0, -47, -48, 8, 0, 45, 100],
# #             112: [-30, 0, -70, -20, 0, 45, 100],

# #             #########################

# #             201: [-30, 0, -70, -20, 0, 45, 100],
# #             202: [0, -47, -48, 8, -60, 45, 100],
# #             203: [0, -47, -48, 8, 0, 45, 0],
# #             204: [0, 0, -40, -45, 0, 45, 0],
# #             205: [-160, -47, -48, 8, 0, -45, 0],
# #             206: [-160, -47, -48, 8, -60, -45, 100],
# #             207: [0, 0, 0, -90, 0, 45, 100],
# #             208: [0, -55, -47, 11, -60, 45, 100],
# #             209: [0, -55, -47, 11, 0, 45, 0],
# #             210: [0, 0, -40, -45, 0, 45, 0],
# #             211: [-160, -47, -48, 8, 0, -45, 0],
# #             212: [-160, -47, -48, 8, -60, -45, 100],
# #             213: [-30, 0, -70, -20, 0, 45, 100],
# #         }

# #     def publish_ready(self):
# #         if not self.ready_log_printed:
# #             self.get_logger().info("üì° Ï§ÄÎπÑ Ïã†Ìò∏ Î∞úÌñâ (/a_1_ready)")
# #             self.ready_log_printed = True
# #         self.ready_pub.publish(Bool(data=True))

# #     def step_callback(self, msg):
# #         step = msg.data
# #         if step == self.executing_step:
# #             return
# #         self.executing_step = step
# #         self.last_step_time = time.time()
# #         if step == 999:
# #             self.mc.send_angles([30, 0, -90, 0, 0, -45], 30)
# #             time.sleep(1.0)
# #             self.mc.set_gripper_value(100, 50)
# #             time.sleep(0.5)
# #             self.to_marker()
# #             self.step_done = True
# #         elif step in self.action_map:
# #             angles = self.action_map[step]
# #             self.get_logger().info(f"‚ñ∂Ô∏è [A-1] Step {step} Ïã§Ìñâ: {angles}")
# #             try:
# #                 self.mc.send_angles(angles[:6], 30)
# #                 self.mc.set_gripper_value(angles[6], 30)
# #                 time.sleep(2)
# #                 self.get_logger().info(f"‚úÖ Step {step} ÏôÑÎ£å")
# #                 self.step_done = True
# #             except Exception as e:
# #                 self.get_logger().error(f"‚ùå Step {step} Ïã§Ìå®: {e}")
# #         else:
# #             self.get_logger().warn(f"‚ö†Ô∏è Step {step} Ï†ïÏùò ÏïàÎê®")
# #             self.step_done = True

# #     def publish_done_if_needed(self):
# #         if self.step_done:
# #             self.done_pub.publish(Bool(data=True))
# #             self.get_logger().info("üì§ ÏôÑÎ£å Ïã†Ìò∏ Ï†ÑÏÜ° (/a_1_done)")
# #             self.step_done = False
# #             self.executing_step = None
# #             self.last_step_time = None

# #     def check_step_timeout(self):
# #         if self.executing_step and self.last_step_time:
# #             if time.time() - self.last_step_time > 5.0:
# #                 self.get_logger().warn(f"‚è±Ô∏è Step {self.executing_step} ÌÉÄÏûÑÏïÑÏõÉ ‚Üí Ïû¨Ïã§Ìñâ")
# #                 self.step_callback(Int32(data=self.executing_step))

# #     def to_marker(self):
# #         global DT
# #         # 1. ÏµúÏã† ÌîÑÎ†àÏûÑÏóêÏÑú ÎßàÏª§ Í≤ÄÏ∂ú
# #         corners, ids, _ = aruco.detectMarkers(
# #             cv2.cvtColor(latest_frame, cv2.COLOR_BGR2GRAY),
# #             ARUCO_DICT,
# #             parameters=ARUCO_PARAMS
# #         )
# #         if ids is None:
# #             self.get_logger().warn("‚ùå ÎßàÏª§ Ïù∏Ïãù Ïã§Ìå®")
# #             return

# #         # 2. PnPÎ°ú ÎßàÏª§ ÏúÑÏπò Ï∂îÏ†ï
# #         rvec, tvec, _ = aruco.estimatePoseSingleMarkers(
# #             corners, MARKER_LEN, CAM_MTX, DIST_COEFFS
# #         )
# #         tvec_mean = np.mean(tvec, axis=0)[0]  # [tx, ty, tz]

# #         # 3. Ï¢åÌëú Î≥ÄÌôò: Ïπ¥Î©îÎùº Í∏∞Ï§Ä ‚Üí Î≤†Ïù¥Ïä§ Í∏∞Ï§Ä (YÏ∂ï Î∞òÏ†Ñ)
# #         tvec_fixed = np.array([
# #             round(-tvec_mean[1], 1),  # Y
# #             round(-tvec_mean[0], 1),  # X
# #             round(tvec_mean[2], 1)    # Z
# #         ])

# #         # 4. ÏµúÏ¢Ö Î™©Ìëú Ï¢åÌëú Í≥ÑÏÇ∞ (Î≥¥Ï†ïÍ∞í + Î≥ÄÌôòÎêú tvec)
# #         target_pos = DT + tvec_fixed
# #         ori = [0.0, 0.0, -45.0]  # Í≥†Ï†ï ÏûêÏÑ∏ ÏÇ¨Ïö©
# #         target = np.round(target_pos, 1).tolist() + ori

# #         # 5. Î°úÎ¥á Ïù¥Îèô
# #         self.mc.send_coords(target, speed=SLOW_SPEED, mode=BLEND_MODE)
# #         time.sleep(3)
# #         self.get_logger().info(f"üìç ÎßàÏª§Î°ú Ïù¥Îèô ÏôÑÎ£å ‚Üí {target}")



# # def local_ip():
# #     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# #     s.connect(("8.8.8.8", 80))
# #     ip = s.getsockname()[0]
# #     s.close()
# #     return ip

# # def main(args=None):
# #     threading.Thread(target=stream_cam, daemon=True).start()
# #     threading.Thread(target=lambda: app.run(host='0.0.0.0', port=9816, debug=False), daemon=True).start()
# #     print(f"üåê Ïõπ Ïä§Ìä∏Î¶¨Î∞ç ÏãúÏûë: http://{local_ip()}:9816")
# #     rclpy.init(args=args)
# #     node = RobotA1Node()
# #     try:
# #         rclpy.spin(node)
# #     except KeyboardInterrupt:
# #         pass
# #     node.destroy_node()
# #     rclpy.shutdown()

# # if __name__ == '__main__':
# #     main()
