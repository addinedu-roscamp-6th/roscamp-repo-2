# import rclpy
# from rclpy.node import Node
# from std_msgs.msg import Int32, Bool
# import time

# from pymycobot.mycobot280 import MyCobot280

# class RobotA1Node(Node):
#     def __init__(self):
#         super().__init__('robot_a1_node')

#         # MyCobot ì—°ê²°
#         self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
#         self.mc.thread_lock = True
#         self.get_logger().info("ğŸ¤– JetCobot A ì—°ê²° ì™„ë£Œ")

#         # âœ… í¼ë¸”ë¦¬ì…” ë° ì„œë¸ŒìŠ¤í¬ë¼ì´ë²„ ìƒì„±
#         self.ready_pub = self.create_publisher(Bool, '/a_1_ready', 10)
#         self.done_pub = self.create_publisher(Bool, '/a_1_done', 10)
#         self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, 10)

#         # âœ… ì¤€ë¹„ ì‹ í˜¸ ë°˜ë³µ ë°œí–‰ (0.5ì´ˆë§ˆë‹¤)
#         self.create_timer(0.5, self.publish_ready)

#         # âœ… ì™„ë£Œ ì‹ í˜¸ ì¬ë°œí–‰ì„ ìœ„í•œ íƒ€ì´ë¨¸ (0.1ì´ˆë§ˆë‹¤)
#         self.create_timer(0.1, self.publish_done_if_needed)

#         # âœ… ë™ì‘ ì¬ì‹¤í–‰ ê°ì‹œ íƒ€ì´ë¨¸ (2ì´ˆë§ˆë‹¤)
#         self.create_timer(2.0, self.check_step_timeout)

#         # âœ… ì´ˆê¸° ìƒíƒœ
#         self.step_done = False
#         self.executing_step = None
#         self.last_step_time = None

#         # âœ… ì´ˆê¸°í™”
#         self.mc.send_angles([0, 0, 0, 0, 0, 0], 30)
#         self.mc.set_gripper_value(100, 30)
#         time.sleep(2)
#         self.get_logger().info("ğŸ”„ ì¤€ë¹„ ìì„¸ ì™„ë£Œ")

#         self.ready_log_printed = False

#         # âœ… ë™ì‘ í…Œì´ë¸”
#         self.action_map = {
#             101: [-30, 0, -70, -20, 0, 45, 100],
#             102: [0, 0, -150, 60, -60, 45, 100],
#             103: [0, 0, -150, 60, 0, 45, 0],
#             104: [0, 0, -40, -45, 0, 45, 0],
#             105: [0, -55, -47, 11, 0, 45, 0],
#             106: [0, -55, -47, 11, 0, 45, 100],
#             107: [0, 0, -40, -45, 0, 45, 0],
#             108: [0, 0, -150, 60, -60, 45, 100],
#             109: [0, 0, -150, 60, 0, 45, 0],
#             110: [0, 0, -40, -45, 0, 45, 0],
#             111: [0, -47, -48, 8, 0, 45, 100],
#             112: [-30, 0, -70, -20, 0, 45, 100],


#             201: [-30, 0, -70, -20, 0, 45, 100],    # ì´ˆê¸°
#             202: [0, -47, -48, 8, -60, 45, 100],    # ì‹íŒ1 ìœ„ì¹˜
#             203: [0, -47, -48, 8, 0, 45, 0],        # ì‹íŒ1 ì¡ê¸°
#             204: [0, 0, -40, -45, 0, 45, 0],        # ì‹íŒ ë“¤ê¸°
#             205: [0, 0, -150, 60, 0, 45, 0],        # ì‹íŒ ë†“ê¸°
#             206: [-168, -50, -60, 20, 0, 55, 0],    # íšŒì „
#             207: [-168, -50, -60, 20, 0, 55, 100], # ë²„ë¦¬ê¸°
#             208: [0, 0, 0, -90, 0, 45, 100],        # ì´ˆê¸°2
#             209: [0, -55, -47, 11, -60, 45, 100],   # ì‹íŒ2 ìœ„ì¹˜
#             210: [0, -55, -47, 11, 0, 45, 0],       # ì‹íŒ2 ì¡ê¸°
#             211: [0, 0, -40, -45, 0, 45, 0],        # ë“¤ê¸°
#             212: [0, 0, -150, 60, 0, 45, 0],        # ë†“ê¸°
#             213: [-168, -50, -60, 20, 0, 55, 0],    # íšŒì „
#             214: [-168, -50, -60, 20, 0, 55, 100], # ë²„ë¦¬ê¸°
#             215: [-30, 0, -70, -20, 0, 45, 100],    # ì´ˆê¸°
#         }

#     def publish_ready(self):
#         if not self.ready_log_printed:
#             self.get_logger().info("ğŸ“¡ ì¤€ë¹„ ì‹ í˜¸ ë°œí–‰ (/a_1_ready)")
#             self.ready_log_printed = True  # âœ… ì´í›„ë¶€í„° ì¶œë ¥í•˜ì§€ ì•ŠìŒ
#         self.ready_pub.publish(Bool(data=True))


#     def step_callback(self, msg):
#         step = msg.data
#         if step == self.executing_step:
#             # ë™ì¼í•œ step ì¬ìˆ˜ì‹  ì‹œ ë¬´ì‹œ
#             return

#         self.executing_step = step
#         self.last_step_time = time.time()

#         if step in self.action_map:
#             angles = self.action_map[step]
#             self.get_logger().info(f"â–¶ï¸ [A-1] Step {step} ë™ì‘ ì‹¤í–‰: {angles}")
#             try:
#                 self.mc.send_angles(angles[:6], 30)
#                 self.mc.set_gripper_value(angles[6], 30)
#                 time.sleep(2)
#                 self.get_logger().info(f"âœ… [A-1] Step {step} ì™„ë£Œ")
#                 self.step_done = True
#             except Exception as e:
#                 self.get_logger().error(f"âŒ Step {step} ì‹¤íŒ¨: {e}")
#         else:
#             self.get_logger().warn(f"âš ï¸ Step {step}ì€ Aê°€ ìˆ˜í–‰í•  ìˆ˜ ì—†ìŒ")
#             self.step_done = True

#     def publish_done_if_needed(self):
#         if self.step_done:
#             self.done_pub.publish(Bool(data=True))
#             self.get_logger().info("ğŸ“¤ ì™„ë£Œ ì‹ í˜¸ ì „ì†¡ (/a_1_done)")
#             self.step_done = False
#             self.executing_step = None
#             self.last_step_time = None

#     def check_step_timeout(self):
#         if self.executing_step is not None and self.last_step_time is not None:
#             elapsed = time.time() - self.last_step_time
#             if elapsed > 5.0:
#                 self.get_logger().warn(f"â±ï¸ Step {self.executing_step} íƒ€ì„ì•„ì›ƒ ë°œìƒ â†’ ê°•ì œ ì¬ì‹¤í–‰")
#                 # ì¬ì‹¤í–‰ ì‹œë„
#                 self.step_callback(Int32(data=self.executing_step))  # ì¬ì „ì†¡

# def main(args=None):
#     rclpy.init(args=args)
#     node = RobotA1Node()
#     try:
#         rclpy.spin(node)
#     except KeyboardInterrupt:
#         pass
#     node.destroy_node()
#     rclpy.shutdown()

# if __name__ == '__main__':
#     main()



# ###########################




# # # âœ… ìµœì¢… í†µí•©: robot_a1_node.py
# # # - ê¸°ì¡´ ì½”ë“œ2ì˜ step ê¸°ë°˜ êµ¬ì¡° ìœ ì§€
# # # - step == 999ì—ì„œë§Œ 1ë²ˆ ê¸°ëŠ¥(ë§ˆì»¤ ì¤‘ì‹¬ ì¶”ì )
# # # - calibration.json ë³´ì •ê°’ ì‚¬ìš©
# # # - Flask ìŠ¤íŠ¸ë¦¬ë° í¬í•¨ (http://<ip>:9816)
# # # - ArUco ë§ˆì»¤ ì¸ì‹ ë° ì¢Œí‘œê³„ ì‹œê°í™”

# # import rclpy
# # from rclpy.node import Node
# # from std_msgs.msg import Int32, Bool
# # import time, threading, socket, signal, sys, atexit, os, json, cv2, numpy as np
# # import cv2.aruco as aruco
# # from flask import Flask, Response
# # from pymycobot.mycobot280 import MyCobot280

# # # === ë³´ì •ê°’ ë¡œë”© ===
# # CAL_FILE = 'calibration.json'
# # DEFAULT_DT = [33.406, 19.536, 246.961]
# # if os.path.exists(CAL_FILE):
# #     try:
# #         with open(CAL_FILE) as f:
# #             DT = np.array(json.load(f)['T_CAM2BASE_STATIC'], float)
# #     except (KeyError, json.JSONDecodeError):
# #         print("âš ï¸ 'T_CAM2BASE_STATIC' ëˆ„ë½ â†’ ê¸°ë³¸ê°’ ì‚¬ìš©")
# #         DT = np.array(DEFAULT_DT, float)
# # else:
# #     DT = np.array(DEFAULT_DT, float)

# # # === ë§ˆì»¤ / ì¹´ë©”ë¼ ì„¤ì • ===
# # MARKER_LEN = 35.0
# # T_TOOL2CAM = np.array([0, 0, 0.0])
# # CAM_MTX = np.array([[2736.98231, 0.0, 320.553729],
# #                     [0.0, 2730.38853, 234.335302],
# #                     [0.0, 0.0, 1.0]])
# # DIST_COEFFS = np.array([[-2.09578526, -43.8402559, -0.0176765795, -0.0463219652, 511.115001]])
# # ARUCO_DICT = aruco.getPredefinedDictionary(aruco.DICT_5X5_50)
# # ARUCO_PARAMS = aruco.DetectorParameters()

# # FAST_SPEED = 50
# # SLOW_SPEED = 12
# # BLEND_MODE = 1

# # app = Flask(__name__)
# # cap = None
# # latest_frame = None
# # lock = threading.Lock()


# # def stream_cam():
# #     global cap, latest_frame
# #     while True:
# #         if cap is None or not cap.isOpened():
# #             cap = cv2.VideoCapture(0)
# #             if not cap.isOpened():
# #                 time.sleep(1)
# #                 continue
# #         ret, fr = cap.read()
# #         if not ret:
# #             time.sleep(0.1)
# #             continue
# #         with lock:
# #             latest_frame = fr
# #         time.sleep(0.03)

# # @app.route('/')
# # def index():
# #     return "<h1>JetCobot A1</h1><img src='/video_feed'>"

# # @app.route('/video_feed')
# # def video_feed():
# #     def gen():
# #         while True:
# #             with lock:
# #                 fr = latest_frame.copy() if latest_frame is not None else None
# #             if fr is None:
# #                 time.sleep(0.03)
# #                 continue
# #             gray = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)
# #             corners, ids, _ = aruco.detectMarkers(gray, ARUCO_DICT, parameters=ARUCO_PARAMS)
# #             if ids is not None:
# #                 aruco.drawDetectedMarkers(fr, corners, ids)
# #                 objp = np.array([[-MARKER_LEN/2, MARKER_LEN/2, 0], [ MARKER_LEN/2, MARKER_LEN/2, 0],
# #                                  [ MARKER_LEN/2,-MARKER_LEN/2, 0], [-MARKER_LEN/2,-MARKER_LEN/2, 0]], np.float32)
# #                 imgp = corners[0].reshape(-1, 2).astype(np.float32)
# #                 success, rvec, tvec = cv2.solvePnP(objp, imgp, CAM_MTX, DIST_COEFFS)
# #                 if success:
# #                     cv2.drawFrameAxes(fr, CAM_MTX, DIST_COEFFS, rvec, tvec, 10)
# #             ret, jpeg = cv2.imencode('.jpg', fr)
# #             if ret:
# #                 yield (b'--frame\r\nContent-Type:image/jpeg\r\n\r\n' + jpeg.tobytes() + b'\r\n')
# #             time.sleep(0.03)
# #     return Response(gen(), mimetype='multipart/x-mixed-replace; boundary=frame')

# # def euler_to_R(rx, ry, rz):
# #     a, b, c = np.deg2rad([rx, ry, rz])
# #     Rz = np.array([[np.cos(c), -np.sin(c), 0], [np.sin(c), np.cos(c), 0], [0, 0, 1]])
# #     Ry = np.array([[np.cos(b), 0, np.sin(b)], [0, 1, 0], [-np.sin(b), 0, np.cos(b)]])
# #     Rx = np.array([[1, 0, 0], [0, np.cos(a), -np.sin(a)], [0, np.sin(a), np.cos(a)]])
# #     return Rz @ Ry @ Rx

# # class RobotA1Node(Node):
# #     def __init__(self):
# #         super().__init__('robot_a1_node')
# #         self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
# #         self.mc.thread_lock = True
# #         self.get_logger().info("ğŸ¤– JetCobot A ì—°ê²° ì™„ë£Œ")

# #         self.ready_pub = self.create_publisher(Bool, '/a_1_ready', 10)
# #         self.done_pub = self.create_publisher(Bool, '/a_1_done', 10)
# #         self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, 10)
# #         self.create_timer(0.5, self.publish_ready)
# #         self.create_timer(0.1, self.publish_done_if_needed)
# #         self.create_timer(2.0, self.check_step_timeout)

# #         self.step_done = False
# #         self.executing_step = None
# #         self.last_step_time = None

# #         self.mc.send_angles([0]*6, 30)
# #         self.mc.set_gripper_value(100, 30)
# #         time.sleep(2)
# #         self.get_logger().info("ğŸ”„ ì¤€ë¹„ ìì„¸ ì™„ë£Œ")

# #         self.ready_log_printed = False

# #         self.action_map = {
# #             101: [-30, 0, -70, -20, 0, 45, 100],

# #             #ì—¬ê¸°ê°€ ë§ˆì»¤ ì¸ì‹ìœ¼ë¡œ í•´ì„œ ê°€ì•¼í•  ê²ƒ

# #             102: [0, 0, -150, 60, -60, 45, 100],
# #             103: [0, 0, -150, 60, 0, 45, 0],
# #             104: [0, 0, -40, -45, 0, 45, 0],
# #             105: [0, -55, -47, 11, 0, 45, 0],
# #             106: [0, -55, -47, 11, 0, 45, 100],
# #             107: [0, 0, -40, -45, 0, 45, 0],
# #             108: [0, 0, -150, 60, -60, 45, 100],
# #             109: [0, 0, -150, 60, 0, 45, 0],
# #             110: [0, 0, -40, -45, 0, 45, 0],
# #             111: [0, -47, -48, 8, 0, 45, 100],
# #             112: [-30, 0, -70, -20, 0, 45, 100],

# #             #########################

# #             201: [-30, 0, -70, -20, 0, 45, 100],
# #             202: [0, -47, -48, 8, -60, 45, 100],
# #             203: [0, -47, -48, 8, 0, 45, 0],
# #             204: [0, 0, -40, -45, 0, 45, 0],
# #             205: [-160, -47, -48, 8, 0, -45, 0],
# #             206: [-160, -47, -48, 8, -60, -45, 100],
# #             207: [0, 0, 0, -90, 0, 45, 100],
# #             208: [0, -55, -47, 11, -60, 45, 100],
# #             209: [0, -55, -47, 11, 0, 45, 0],
# #             210: [0, 0, -40, -45, 0, 45, 0],
# #             211: [-160, -47, -48, 8, 0, -45, 0],
# #             212: [-160, -47, -48, 8, -60, -45, 100],
# #             213: [-30, 0, -70, -20, 0, 45, 100],
# #         }

# #     def publish_ready(self):
# #         if not self.ready_log_printed:
# #             self.get_logger().info("ğŸ“¡ ì¤€ë¹„ ì‹ í˜¸ ë°œí–‰ (/a_1_ready)")
# #             self.ready_log_printed = True
# #         self.ready_pub.publish(Bool(data=True))

# #     def step_callback(self, msg):
# #         step = msg.data
# #         if step == self.executing_step:
# #             return
# #         self.executing_step = step
# #         self.last_step_time = time.time()
# #         if step == 999:
# #             self.mc.send_angles([30, 0, -90, 0, 0, -45], 30)
# #             time.sleep(1.0)
# #             self.mc.set_gripper_value(100, 50)
# #             time.sleep(0.5)
# #             self.to_marker()
# #             self.step_done = True
# #         elif step in self.action_map:
# #             angles = self.action_map[step]
# #             self.get_logger().info(f"â–¶ï¸ [A-1] Step {step} ì‹¤í–‰: {angles}")
# #             try:
# #                 self.mc.send_angles(angles[:6], 30)
# #                 self.mc.set_gripper_value(angles[6], 30)
# #                 time.sleep(2)
# #                 self.get_logger().info(f"âœ… Step {step} ì™„ë£Œ")
# #                 self.step_done = True
# #             except Exception as e:
# #                 self.get_logger().error(f"âŒ Step {step} ì‹¤íŒ¨: {e}")
# #         else:
# #             self.get_logger().warn(f"âš ï¸ Step {step} ì •ì˜ ì•ˆë¨")
# #             self.step_done = True

# #     def publish_done_if_needed(self):
# #         if self.step_done:
# #             self.done_pub.publish(Bool(data=True))
# #             self.get_logger().info("ğŸ“¤ ì™„ë£Œ ì‹ í˜¸ ì „ì†¡ (/a_1_done)")
# #             self.step_done = False
# #             self.executing_step = None
# #             self.last_step_time = None

# #     def check_step_timeout(self):
# #         if self.executing_step and self.last_step_time:
# #             if time.time() - self.last_step_time > 5.0:
# #                 self.get_logger().warn(f"â±ï¸ Step {self.executing_step} íƒ€ì„ì•„ì›ƒ â†’ ì¬ì‹¤í–‰")
# #                 self.step_callback(Int32(data=self.executing_step))

# #     def to_marker(self):
# #         global DT
# #         # 1. ìµœì‹  í”„ë ˆì„ì—ì„œ ë§ˆì»¤ ê²€ì¶œ
# #         corners, ids, _ = aruco.detectMarkers(
# #             cv2.cvtColor(latest_frame, cv2.COLOR_BGR2GRAY),
# #             ARUCO_DICT,
# #             parameters=ARUCO_PARAMS
# #         )
# #         if ids is None:
# #             self.get_logger().warn("âŒ ë§ˆì»¤ ì¸ì‹ ì‹¤íŒ¨")
# #             return

# #         # 2. PnPë¡œ ë§ˆì»¤ ìœ„ì¹˜ ì¶”ì •
# #         rvec, tvec, _ = aruco.estimatePoseSingleMarkers(
# #             corners, MARKER_LEN, CAM_MTX, DIST_COEFFS
# #         )
# #         tvec_mean = np.mean(tvec, axis=0)[0]  # [tx, ty, tz]

# #         # 3. ì¢Œí‘œ ë³€í™˜: ì¹´ë©”ë¼ ê¸°ì¤€ â†’ ë² ì´ìŠ¤ ê¸°ì¤€ (Yì¶• ë°˜ì „)
# #         tvec_fixed = np.array([
# #             round(-tvec_mean[1], 1),  # Y
# #             round(-tvec_mean[0], 1),  # X
# #             round(tvec_mean[2], 1)    # Z
# #         ])

# #         # 4. ìµœì¢… ëª©í‘œ ì¢Œí‘œ ê³„ì‚° (ë³´ì •ê°’ + ë³€í™˜ëœ tvec)
# #         target_pos = DT + tvec_fixed
# #         ori = [0.0, 0.0, -45.0]  # ê³ ì • ìì„¸ ì‚¬ìš©
# #         target = np.round(target_pos, 1).tolist() + ori

# #         # 5. ë¡œë´‡ ì´ë™
# #         self.mc.send_coords(target, speed=SLOW_SPEED, mode=BLEND_MODE)
# #         time.sleep(3)
# #         self.get_logger().info(f"ğŸ“ ë§ˆì»¤ë¡œ ì´ë™ ì™„ë£Œ â†’ {target}")



# # def local_ip():
# #     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# #     s.connect(("8.8.8.8", 80))
# #     ip = s.getsockname()[0]
# #     s.close()
# #     return ip

# # def main(args=None):
# #     threading.Thread(target=stream_cam, daemon=True).start()
# #     threading.Thread(target=lambda: app.run(host='0.0.0.0', port=9816, debug=False), daemon=True).start()
# #     print(f"ğŸŒ ì›¹ ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘: http://{local_ip()}:9816")
# #     rclpy.init(args=args)
# #     node = RobotA1Node()
# #     try:
# #         rclpy.spin(node)
# #     except KeyboardInterrupt:
# #         pass
# #     node.destroy_node()
# #     rclpy.shutdown()

# # if __name__ == '__main__':
# #     main()
