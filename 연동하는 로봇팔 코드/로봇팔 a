import os, time, threading, socket, sys
import cv2
import numpy as np

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32
from flask import Flask, Response
from pymycobot.mycobot280 import MyCobot280

# ── 간단 웹뷰: CODE1 동안 최신 프레임만 업데이트 ─────────────
app = Flask(__name__)
_latest_frame = None
_frame_lock = threading.Lock()

@app.route('/')
def index():
    return "<h1>JetCobot A - Camera</h1><div><img src='/video_feed'></div>"

@app.route('/video_feed')
def video_feed():
    def gen():
        while True:
            with _frame_lock:
                fr = None if _latest_frame is None else _latest_frame.copy()
            if fr is None:
                time.sleep(0.03)
                continue
            h, w = fr.shape[:2]
            cv2.drawMarker(fr, (w//2, h//2), (0,255,0), cv2.MARKER_CROSS, 20, 2)
            ok, jpg = cv2.imencode('.jpg', fr)
            if ok:
                yield (b'--frame\r\nContent-Type:image/jpeg\r\n\r\n' +
                       jpg.tobytes() + b'\r\n')
            time.sleep(0.03)
    return Response(gen(), mimetype='multipart/x-mixed-replace;boundary=frame')

def start_web():
    def local_ip():
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 9816))
            ip = s.getsockname()[0]; s.close(); return ip
        except Exception:
            return "127.0.0.1"
    threading.Thread(target=lambda: app.run(host='0.0.0.0', port=9816, debug=False, use_reloader=False, threaded=True), daemon=True).start()
    print(f"🌐 카메라 미리보기: http://{local_ip()}:9816")

# ───────────────────────────────────────────────

class RobotA1Node(Node):
    def __init__(self):
        super().__init__('robot_a_1_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # HW
        self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
        self.mc.thread_lock = True
        self.get_logger().info("🤖 JetCobot A 연결 완료")

        # 상태
        self.step_running = threading.Event()
        self.waiting_barrier = False
        self.executing_step = None
        self.pending_step = None
        self.last_step_time = None
        self.worker_thread = None
        self.step_done = False

        # Pub/Sub
        self.done_pub = self.create_publisher(Int32, '/a_1_done', self.qos1)
        self.ready_pub = self.create_publisher(Int32, '/a_ready_step', self.qos1)
        self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, self.qos1)
        self.create_subscription(Int32, '/go_step', self.go_callback, self.qos1)

        # 타이머
        self.create_timer(0.3, self.tick_timeout)

        # CODE1 파라미터
        self.DT = np.array([36.38920224272615, -59.19202261629651, -116.73972075865049], float)
        self.CAM_MTX = np.array([[2736.98231, 0.0, 320.553729],
                                 [0.0, 2730.38853, 234.335302],
                                 [0.0, 0.0, 1.0]])
        self.DIST_COEFFS = np.array([[-2.09578526, -43.8402559, -0.0176765795, -0.0463219652, 511.115001]])
        self.MARKER_LEN = 5.0
        self.T_TOOL2CAM = np.array([0.0, 0.0, 0.0])   # ← 반드시 존재하도록 유지

        self.FAST_SPEED = 50
        self.SLOW_SPEED = 12
        self.BLEND_MODE = 1

        self.BASIC_POSE = [0, 55, -90, -55, 6, -45]

        # 동작 맵 (필요에 맞게 유지/수정)
        self.action_map = {
            101: [0, 0, -70, -20, 0, 45, 100],
            102: "CODE1",
            103: [0, 40, -130, 0, -60, 45, 100],
            104: [0, 40, -130, 0, 6, 45, 100],
            105: [0, 40, -130, 0, 6, 45, 0],
            106: [0, 0, -40, -48, 6, 45, 0],
            107: [0, -25, -65, 0, 6, 45, 0],
            108: [0, -25, -65, 0, 6, 45, 100],
            109: [0, 0, -40, -48, 6, 45, 100],
            110: "CODE1",
            111: [0, 40, -130, 0, -60, 45, 100],
            112: [0, 40, -130, 0, 6, 45, 100],
            113: [0, 40, -130, 0, 6, 45, 0],
            114: [0, 0, -40, -48, 6, 45, 0],
            115: [0, -20, -60, -5, 6, 45, 0],
            116: [0, -20, -60, -5, 6, 45, 100],
            117: [0, 0, -70, -20, 0, 45, 100],

            201: [0, 0, -70, -20, 0, 45, 100],
            202: [0, -20, -60, -5, -60, 45, 100],
            203: [0, -20, -60, -5, 6, 45, 100],
            204: [0, -20, -60, -5, 6, 45, 0],
            205: [0, 0, -40, -48, 6, 45, 0],
            206: [0, 40, -130, 0, 6, 45, 0],
            207: [0, 40, -130, 0, 6, 45, 100],
            208: [0, -25, -65, -5, -60, 45, 100],
            209: [0, -25, -65, -5, 6, 45, 100],
            210: [0, -25, -65, -5, 6, 45, 0],
            211: [0, 0, -40, -48, 6, 45, 0],
            212: [0, 40, -130, 0, 6, 45, 0],
            213: [0, 40, -130, 0, 6, 45, 100],
            214: [0, 0, -70, -20, 0, 45, 100],
        }

        # 웹 서버 시작 (프레임은 CODE1 동안만 업데이트)
        start_web()

    # ────────────────────────────── 유틸
    @staticmethod
    def euler_to_R(rx, ry, rz):
        a, b, c = np.deg2rad([rx, ry, rz])
        cz, sz = np.cos(c), np.sin(c)
        cy, sy = np.cos(b), np.sin(b)
        cx, sx = np.cos(a), np.sin(a)
        Rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])
        Ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])
        Rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])
        return Rz @ Ry @ Rx

    @staticmethod
    def clamp(v, lo, hi): return lo if v < lo else (hi if v > hi else v)

    # ────────────────────────────── 마커 안정 대기(카메라 CODE1에서만 사용)
    def _wait_for_stable_marker(self, still_time=2.0, pos_eps=1.5, timeout=20.0, poll=0.05):
        cap = cv2.VideoCapture(0)
        if cap.isOpened():
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            cap.set(cv2.CAP_PROP_FPS, 30)
            cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        else:
            raise RuntimeError("카메라 열기 실패(/dev/video0)")

        try:
            ARUCO_DICT = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_50)
            ARUCO_PARAMS = cv2.aruco.DetectorParameters()
            objp = np.array([
                [-self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
                [ self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
                [ self.MARKER_LEN/2, -self.MARKER_LEN/2, 0],
                [-self.MARKER_LEN/2, -self.MARKER_LEN/2, 0]
            ], dtype=np.float32)

            t0 = time.time()
            anchor_t = None; anchor_ts = None
            last_ok = None

            while time.time() - t0 < timeout:
                ok, fr = cap.read()
                if not ok:
                    time.sleep(0.02); continue

                # 웹뷰에 노출 (CODE1 동안만 갱신)
                with _frame_lock:
                    globals()['_latest_frame'] = fr

                gray = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)
                corners, ids, _ = cv2.aruco.detectMarkers(gray, ARUCO_DICT, parameters=ARUCO_PARAMS)
                if ids is None or len(corners) == 0:
                    anchor_t = None; anchor_ts = None
                    time.sleep(poll); continue

                imgp = corners[0].reshape(-1, 2).astype(np.float32)
                ok, rvec, tvec = cv2.solvePnP(objp, imgp, self.CAM_MTX, self.DIST_COEFFS)
                if not ok:
                    time.sleep(poll); continue

                t = tvec.flatten()
                if anchor_t is None:
                    anchor_t = t; anchor_ts = time.time(); last_ok = (rvec, tvec)
                else:
                    if np.linalg.norm(t - anchor_t) <= pos_eps:
                        last_ok = (rvec, tvec)
                        if time.time() - anchor_ts >= still_time:
                            return last_ok
                    else:
                        anchor_t = t; anchor_ts = time.time(); last_ok = (rvec, tvec)

                time.sleep(poll)

            return last_ok
        finally:
            cap.release()

    # ────────────────────────────── CODE1 핵심
    def to_marker_basic(self):
        det = self._wait_for_stable_marker(still_time=2.0, pos_eps=1.5, timeout=20.0, poll=0.05)
        if det is None:
            raise RuntimeError("마커를 인식하지 못했습니다.")
        rvec, tvec = det

        # 1) 마커 중심으로 이동
        tvec = tvec.flatten()
        tvec_fixed = np.array([ round(-tvec[1],1), round(-tvec[0],1), round(tvec[2],1) ])

        coords = self.mc.get_coords()
        if coords is None: raise RuntimeError("get_coords() 실패")
        ori = [round(x,1) for x in coords[3:]]
        R_tool = self.euler_to_R(*ori)
        T_tool_in_base = np.round(R_tool @ self.T_TOOL2CAM, 1)

        marker_abs_pos = np.round(self.DT + tvec_fixed + T_tool_in_base, 1)
        current_coords = np.array(coords[:3])
        delta = marker_abs_pos - current_coords

        correction_offset = np.array([45.0, 0.0, 0.0])
        target_coords = current_coords + delta + correction_offset
        target_coords[2] = 165.0

        self.mc.send_coords(target_coords.tolist() + ori, speed=self.SLOW_SPEED, mode=self.BLEND_MODE)
        time.sleep(5)

        # 2) J6 임시 회전 → 그리퍼 닫기(0) → J6 원위치
        try:
            rmat, _ = cv2.Rodrigues(rvec)
            rz = np.degrees(np.arctan2(rmat[1,0], rmat[0,0]))
            rz = ((rz + 180) % 360) - 180
            rz_base = round(rz/90.0)*90
            rz_offset = round(rz - rz_base, 1)

            angles = self.mc.get_angles()
            if angles is None:
                self.get_logger().warn("J6 회전 스킵: 관절 각도 읽기 실패")
            else:
                j6_saved = float(angles[5])  # 현재 J6 저장
                j6_temp  = self.clamp(round(j6_saved + rz_offset, 1), -180.0, 180.0)

                self.get_logger().info(f"J6 저장={j6_saved:.1f}° → 일시 회전={j6_temp:.1f}° (오프셋 {rz_offset:+.1f}°)")
                self.mc.send_angle(6, j6_temp, self.SLOW_SPEED); time.sleep(1.2)

                # 그리퍼 닫기(0)
                self.mc.set_gripper_value(0, 50); time.sleep(0.5)

                # J6 원위치 복귀
                self.get_logger().info(f"J6 복귀 → {j6_saved:.1f}°")
                self.mc.send_angle(6, j6_saved, self.SLOW_SPEED); time.sleep(1.0)

        except Exception as e:
            self.get_logger().warn(f"J6 일시 회전/복귀 처리 실패: {e}")

        # 3) 요청한 최종 자세로 이동: [0, 40, -130, 0, 6, -45, 0]
        try:
            # --- 최종 자세 이동 ---
            final_angles = [0, 40, -130, 0, 6, -45]  # 관절 1~6
            self.mc.send_angles(final_angles, self.FAST_SPEED)
            time.sleep(0.7)

            # --- 그리퍼 열기 ---
            self.mc.set_gripper_value(100, 50)
            time.sleep(0.5)

            # --- 관절 5를 -60도로 회전 ---
            self.mc.send_angle(5, -60, self.FAST_SPEED)
            time.sleep(0.5)

            self.get_logger().info("📌 최종 자세 [0,40,-130,0,6,-45] & 그리퍼=100 → 관절5=-60 완료")

        except Exception as e:
            self.get_logger().error(f"최종 자세 이동 실패: {e}")


    def run_code1_feature(self):
        self.get_logger().info("🧩 코드1 기능 실행 시작")
        self.mc.send_angles(self.BASIC_POSE, self.FAST_SPEED); time.sleep(0.5)
        self.mc.set_gripper_value(100, 50); time.sleep(0.3)
        self.to_marker_basic()
        self.get_logger().info("🧩 코드1 기능 완료")

    # ────────────────────────────── 배리어 프로토콜
    def step_callback(self, msg):
        step = int(msg.data)

        # 실행 중/배리어 대기 중이면 큐잉
        if self.step_running.is_set() or self.waiting_barrier:
            if step != self.executing_step:
                self.pending_step = step
                self.get_logger().warn(f"🧺 실행/대기 중({self.executing_step}) → Step {step} 큐잉")
            return

        # 새 step 수락 → READY 발행만 하고 대기
        self.executing_step = step
        self.step_done = False
        self.last_step_time = time.time()
        self.waiting_barrier = True
        self.ready_pub.publish(Int32(data=step))
        self.get_logger().info(f"🟡 READY 전송: {step} (GO 대기)")

    def go_callback(self, msg):
        go = int(msg.data)
        if self.waiting_barrier and go == self.executing_step:
            # 동시에 시작
            self.waiting_barrier = False
            self.step_running.set()
            if (go in self.action_map and self.action_map[go] == "CODE1"):
                self.worker_thread = threading.Thread(target=self.execute_code1_step, args=(go,), daemon=True)
            else:
                self.worker_thread = threading.Thread(target=self.execute_step, args=(go,), daemon=True)
            self.worker_thread.start()

    def execute_code1_step(self, step):
        try:
            self.run_code1_feature()
            self.step_done = True
            self.get_logger().info(f"✅ Step {step} (CODE1) 완료")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"❌ Step {step} (CODE1) 실패: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            # 큐에 다음 step 있으면 바로 READY 전송
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def execute_step(self, step):
        angles = self.action_map[step]
        try:
            self.mc.send_angles(angles[:6], 30)
            self.mc.set_gripper_value(angles[6], 30)
            time.sleep(2)
            self.step_done = True
            self.get_logger().info(f"✅ Step {step} 완료")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"❌ Step {step} 실패: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def tick_timeout(self):
        # 배리어에서 오래 기다리면 READY 다시 송신
        if self.waiting_barrier and self.executing_step is not None:
            if time.time() - self.last_step_time > 3.0:
                self.ready_pub.publish(Int32(data=int(self.executing_step)))
                self.last_step_time = time.time()
                self.get_logger().warn(f"⏳ READY 재전송: {self.executing_step}")

def main(args=None):
    # OpenCV 로그 줄이기(선택)
    try:
        cv2.utils.logging.setLogLevel(cv2.utils.logging.LOG_LEVEL_SILENT)
    except Exception:
        pass

    rclpy.init(args=args)
    node = RobotA1Node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
