import os, time, threading, socket, sys
import cv2
import numpy as np

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32
from flask import Flask, Response
from pymycobot.mycobot280 import MyCobot280

# â”€â”€ ê°„ë‹¨ ì›¹ë·°: CODE1 ë™ì•ˆ ìµœì‹  í”„ë ˆì„ë§Œ ì—…ë°ì´íŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app = Flask(__name__)
_latest_frame = None
_frame_lock = threading.Lock()

@app.route('/')
def index():
    return "<h1>JetCobot A - Camera</h1><div><img src='/video_feed'></div>"

@app.route('/video_feed')
def video_feed():
    def gen():
        while True:
            with _frame_lock:
                fr = None if _latest_frame is None else _latest_frame.copy()
            if fr is None:
                time.sleep(0.03)
                continue
            h, w = fr.shape[:2]
            cv2.drawMarker(fr, (w//2, h//2), (0,255,0), cv2.MARKER_CROSS, 20, 2)
            ok, jpg = cv2.imencode('.jpg', fr)
            if ok:
                yield (b'--frame\r\nContent-Type:image/jpeg\r\n\r\n' +
                       jpg.tobytes() + b'\r\n')
            time.sleep(0.03)
    return Response(gen(), mimetype='multipart/x-mixed-replace;boundary=frame')

def start_web():
    def local_ip():
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 9816))
            ip = s.getsockname()[0]; s.close(); return ip
        except Exception:
            return "127.0.0.1"
    threading.Thread(target=lambda: app.run(host='0.0.0.0', port=9816, debug=False, use_reloader=False, threaded=True), daemon=True).start()
    print(f"ğŸŒ ì¹´ë©”ë¼ ë¯¸ë¦¬ë³´ê¸°: http://{local_ip()}:9816")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class RobotA1Node(Node):
    def __init__(self):
        super().__init__('robot_a_1_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # HW
        self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
        self.mc.thread_lock = True
        self.get_logger().info("ğŸ¤– JetCobot A ì—°ê²° ì™„ë£Œ")

        # ìƒíƒœ
        self.step_running = threading.Event()
        self.waiting_barrier = False
        self.executing_step = None
        self.pending_step = None
        self.last_step_time = None
        self.worker_thread = None
        self.step_done = False

        # Pub/Sub
        self.done_pub = self.create_publisher(Int32, '/a_1_done', self.qos1)
        self.ready_pub = self.create_publisher(Int32, '/a_ready_step', self.qos1)
        self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, self.qos1)
        self.create_subscription(Int32, '/go_step', self.go_callback, self.qos1)

        # íƒ€ì´ë¨¸
        self.create_timer(0.3, self.tick_timeout)

        # CODE1 íŒŒë¼ë¯¸í„°
        self.DT = np.array([36.38920224272615, -59.19202261629651, -116.73972075865049], float)
        self.CAM_MTX = np.array([[2736.98231, 0.0, 320.553729],
                                 [0.0, 2730.38853, 234.335302],
                                 [0.0, 0.0, 1.0]])
        self.DIST_COEFFS = np.array([[-2.09578526, -43.8402559, -0.0176765795, -0.0463219652, 511.115001]])
        self.MARKER_LEN = 5.0
        self.T_TOOL2CAM = np.array([0.0, 0.0, 0.0])   # â† ë°˜ë“œì‹œ ì¡´ì¬í•˜ë„ë¡ ìœ ì§€

        self.FAST_SPEED = 50
        self.SLOW_SPEED = 12
        self.BLEND_MODE = 1

        self.BASIC_POSE = [0, 55, -90, -55, 6, -45]

        # ë™ì‘ ë§µ (í•„ìš”ì— ë§ê²Œ ìœ ì§€/ìˆ˜ì •)
        self.action_map = {
            101: [0, 0, -70, -20, 0, 45, 100],
            102: "CODE1",
            103: [0, 40, -130, 0, -60, 45, 100],
            104: [0, 40, -130, 0, 6, 45, 100],
            105: [0, 40, -130, 0, 6, 45, 0],
            106: [0, 0, -40, -48, 6, 45, 0],
            107: [0, -25, -65, 0, 6, 45, 0],
            108: [0, -25, -65, 0, 6, 45, 100],
            109: [0, 0, -40, -48, 6, 45, 100],
            110: "CODE1",
            111: [0, 40, -130, 0, -60, 45, 100],
            112: [0, 40, -130, 0, 6, 45, 100],
            113: [0, 40, -130, 0, 6, 45, 0],
            114: [0, 0, -40, -48, 6, 45, 0],
            115: [0, -20, -60, -5, 6, 45, 0],
            116: [0, -20, -60, -5, 6, 45, 100],
            117: [0, 0, -70, -20, 0, 45, 100],

            201: [0, 0, -70, -20, 0, 45, 100],
            202: [0, -20, -60, -5, -60, 45, 100],
            203: [0, -20, -60, -5, 6, 45, 100],
            204: [0, -20, -60, -5, 6, 45, 0],
            205: [0, 0, -40, -48, 6, 45, 0],
            206: [0, 40, -130, 0, 6, 45, 0],
            207: [0, 40, -130, 0, 6, 45, 100],
            208: [0, -25, -65, -5, -60, 45, 100],
            209: [0, -25, -65, -5, 6, 45, 100],
            210: [0, -25, -65, -5, 6, 45, 0],
            211: [0, 0, -40, -48, 6, 45, 0],
            212: [0, 40, -130, 0, 6, 45, 0],
            213: [0, 40, -130, 0, 6, 45, 100],
            214: [0, 0, -70, -20, 0, 45, 100],
        }

        # ì›¹ ì„œë²„ ì‹œì‘ (í”„ë ˆì„ì€ CODE1 ë™ì•ˆë§Œ ì—…ë°ì´íŠ¸)
        start_web()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìœ í‹¸
    @staticmethod
    def euler_to_R(rx, ry, rz):
        a, b, c = np.deg2rad([rx, ry, rz])
        cz, sz = np.cos(c), np.sin(c)
        cy, sy = np.cos(b), np.sin(b)
        cx, sx = np.cos(a), np.sin(a)
        Rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])
        Ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])
        Rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])
        return Rz @ Ry @ Rx

    @staticmethod
    def clamp(v, lo, hi): return lo if v < lo else (hi if v > hi else v)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë§ˆì»¤ ì•ˆì • ëŒ€ê¸°(ì¹´ë©”ë¼ CODE1ì—ì„œë§Œ ì‚¬ìš©)
    def _wait_for_stable_marker(self, still_time=2.0, pos_eps=1.5, timeout=20.0, poll=0.05):
        cap = cv2.VideoCapture(0)
        if cap.isOpened():
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            cap.set(cv2.CAP_PROP_FPS, 30)
            cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        else:
            raise RuntimeError("ì¹´ë©”ë¼ ì—´ê¸° ì‹¤íŒ¨(/dev/video0)")

        try:
            ARUCO_DICT = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_50)
            ARUCO_PARAMS = cv2.aruco.DetectorParameters()
            objp = np.array([
                [-self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
                [ self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
                [ self.MARKER_LEN/2, -self.MARKER_LEN/2, 0],
                [-self.MARKER_LEN/2, -self.MARKER_LEN/2, 0]
            ], dtype=np.float32)

            t0 = time.time()
            anchor_t = None; anchor_ts = None
            last_ok = None

            while time.time() - t0 < timeout:
                ok, fr = cap.read()
                if not ok:
                    time.sleep(0.02); continue

                # ì›¹ë·°ì— ë…¸ì¶œ (CODE1 ë™ì•ˆë§Œ ê°±ì‹ )
                with _frame_lock:
                    globals()['_latest_frame'] = fr

                gray = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)
                corners, ids, _ = cv2.aruco.detectMarkers(gray, ARUCO_DICT, parameters=ARUCO_PARAMS)
                if ids is None or len(corners) == 0:
                    anchor_t = None; anchor_ts = None
                    time.sleep(poll); continue

                imgp = corners[0].reshape(-1, 2).astype(np.float32)
                ok, rvec, tvec = cv2.solvePnP(objp, imgp, self.CAM_MTX, self.DIST_COEFFS)
                if not ok:
                    time.sleep(poll); continue

                t = tvec.flatten()
                if anchor_t is None:
                    anchor_t = t; anchor_ts = time.time(); last_ok = (rvec, tvec)
                else:
                    if np.linalg.norm(t - anchor_t) <= pos_eps:
                        last_ok = (rvec, tvec)
                        if time.time() - anchor_ts >= still_time:
                            return last_ok
                    else:
                        anchor_t = t; anchor_ts = time.time(); last_ok = (rvec, tvec)

                time.sleep(poll)

            return last_ok
        finally:
            cap.release()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CODE1 í•µì‹¬
    def to_marker_basic(self):
        det = self._wait_for_stable_marker(still_time=2.0, pos_eps=1.5, timeout=20.0, poll=0.05)
        if det is None:
            raise RuntimeError("ë§ˆì»¤ë¥¼ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        rvec, tvec = det

        # 1) ë§ˆì»¤ ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™
        tvec = tvec.flatten()
        tvec_fixed = np.array([ round(-tvec[1],1), round(-tvec[0],1), round(tvec[2],1) ])

        coords = self.mc.get_coords()
        if coords is None: raise RuntimeError("get_coords() ì‹¤íŒ¨")
        ori = [round(x,1) for x in coords[3:]]
        R_tool = self.euler_to_R(*ori)
        T_tool_in_base = np.round(R_tool @ self.T_TOOL2CAM, 1)

        marker_abs_pos = np.round(self.DT + tvec_fixed + T_tool_in_base, 1)
        current_coords = np.array(coords[:3])
        delta = marker_abs_pos - current_coords

        correction_offset = np.array([45.0, 0.0, 0.0])
        target_coords = current_coords + delta + correction_offset
        target_coords[2] = 165.0

        self.mc.send_coords(target_coords.tolist() + ori, speed=self.SLOW_SPEED, mode=self.BLEND_MODE)
        time.sleep(5)

        # 2) J6 ì„ì‹œ íšŒì „ â†’ ê·¸ë¦¬í¼ ë‹«ê¸°(0) â†’ J6 ì›ìœ„ì¹˜
        try:
            rmat, _ = cv2.Rodrigues(rvec)
            rz = np.degrees(np.arctan2(rmat[1,0], rmat[0,0]))
            rz = ((rz + 180) % 360) - 180
            rz_base = round(rz/90.0)*90
            rz_offset = round(rz - rz_base, 1)

            angles = self.mc.get_angles()
            if angles is None:
                self.get_logger().warn("J6 íšŒì „ ìŠ¤í‚µ: ê´€ì ˆ ê°ë„ ì½ê¸° ì‹¤íŒ¨")
            else:
                j6_saved = float(angles[5])  # í˜„ì¬ J6 ì €ì¥
                j6_temp  = self.clamp(round(j6_saved + rz_offset, 1), -180.0, 180.0)

                self.get_logger().info(f"J6 ì €ì¥={j6_saved:.1f}Â° â†’ ì¼ì‹œ íšŒì „={j6_temp:.1f}Â° (ì˜¤í”„ì…‹ {rz_offset:+.1f}Â°)")
                self.mc.send_angle(6, j6_temp, self.SLOW_SPEED); time.sleep(1.2)

                # ê·¸ë¦¬í¼ ë‹«ê¸°(0)
                self.mc.set_gripper_value(0, 50); time.sleep(0.5)

                # J6 ì›ìœ„ì¹˜ ë³µê·€
                self.get_logger().info(f"J6 ë³µê·€ â†’ {j6_saved:.1f}Â°")
                self.mc.send_angle(6, j6_saved, self.SLOW_SPEED); time.sleep(1.0)

        except Exception as e:
            self.get_logger().warn(f"J6 ì¼ì‹œ íšŒì „/ë³µê·€ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")

        # 3) ìš”ì²­í•œ ìµœì¢… ìì„¸ë¡œ ì´ë™: [0, 40, -130, 0, 6, -45, 0]
        try:
            # --- ìµœì¢… ìì„¸ ì´ë™ ---
            final_angles = [0, 40, -130, 0, 6, -45]  # ê´€ì ˆ 1~6
            self.mc.send_angles(final_angles, self.FAST_SPEED)
            time.sleep(0.7)

            # --- ê·¸ë¦¬í¼ ì—´ê¸° ---
            self.mc.set_gripper_value(100, 50)
            time.sleep(0.5)

            # --- ê´€ì ˆ 5ë¥¼ -60ë„ë¡œ íšŒì „ ---
            self.mc.send_angle(5, -60, self.FAST_SPEED)
            time.sleep(0.5)

            self.get_logger().info("ğŸ“Œ ìµœì¢… ìì„¸ [0,40,-130,0,6,-45] & ê·¸ë¦¬í¼=100 â†’ ê´€ì ˆ5=-60 ì™„ë£Œ")

        except Exception as e:
            self.get_logger().error(f"ìµœì¢… ìì„¸ ì´ë™ ì‹¤íŒ¨: {e}")


    def run_code1_feature(self):
        self.get_logger().info("ğŸ§© ì½”ë“œ1 ê¸°ëŠ¥ ì‹¤í–‰ ì‹œì‘")
        self.mc.send_angles(self.BASIC_POSE, self.FAST_SPEED); time.sleep(0.5)
        self.mc.set_gripper_value(100, 50); time.sleep(0.3)
        self.to_marker_basic()
        self.get_logger().info("ğŸ§© ì½”ë“œ1 ê¸°ëŠ¥ ì™„ë£Œ")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë°°ë¦¬ì–´ í”„ë¡œí† ì½œ
    def step_callback(self, msg):
        step = int(msg.data)

        # ì‹¤í–‰ ì¤‘/ë°°ë¦¬ì–´ ëŒ€ê¸° ì¤‘ì´ë©´ íì‰
        if self.step_running.is_set() or self.waiting_barrier:
            if step != self.executing_step:
                self.pending_step = step
                self.get_logger().warn(f"ğŸ§º ì‹¤í–‰/ëŒ€ê¸° ì¤‘({self.executing_step}) â†’ Step {step} íì‰")
            return

        # ìƒˆ step ìˆ˜ë½ â†’ READY ë°œí–‰ë§Œ í•˜ê³  ëŒ€ê¸°
        self.executing_step = step
        self.step_done = False
        self.last_step_time = time.time()
        self.waiting_barrier = True
        self.ready_pub.publish(Int32(data=step))
        self.get_logger().info(f"ğŸŸ¡ READY ì „ì†¡: {step} (GO ëŒ€ê¸°)")

    def go_callback(self, msg):
        go = int(msg.data)
        if self.waiting_barrier and go == self.executing_step:
            # ë™ì‹œì— ì‹œì‘
            self.waiting_barrier = False
            self.step_running.set()
            if (go in self.action_map and self.action_map[go] == "CODE1"):
                self.worker_thread = threading.Thread(target=self.execute_code1_step, args=(go,), daemon=True)
            else:
                self.worker_thread = threading.Thread(target=self.execute_step, args=(go,), daemon=True)
            self.worker_thread.start()

    def execute_code1_step(self, step):
        try:
            self.run_code1_feature()
            self.step_done = True
            self.get_logger().info(f"âœ… Step {step} (CODE1) ì™„ë£Œ")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"âŒ Step {step} (CODE1) ì‹¤íŒ¨: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            # íì— ë‹¤ìŒ step ìˆìœ¼ë©´ ë°”ë¡œ READY ì „ì†¡
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def execute_step(self, step):
        angles = self.action_map[step]
        try:
            self.mc.send_angles(angles[:6], 30)
            self.mc.set_gripper_value(angles[6], 30)
            time.sleep(2)
            self.step_done = True
            self.get_logger().info(f"âœ… Step {step} ì™„ë£Œ")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"âŒ Step {step} ì‹¤íŒ¨: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def tick_timeout(self):
        # ë°°ë¦¬ì–´ì—ì„œ ì˜¤ë˜ ê¸°ë‹¤ë¦¬ë©´ READY ë‹¤ì‹œ ì†¡ì‹ 
        if self.waiting_barrier and self.executing_step is not None:
            if time.time() - self.last_step_time > 3.0:
                self.ready_pub.publish(Int32(data=int(self.executing_step)))
                self.last_step_time = time.time()
                self.get_logger().warn(f"â³ READY ì¬ì „ì†¡: {self.executing_step}")

def main(args=None):
    # OpenCV ë¡œê·¸ ì¤„ì´ê¸°(ì„ íƒ)
    try:
        cv2.utils.logging.setLogLevel(cv2.utils.logging.LOG_LEVEL_SILENT)
    except Exception:
        pass

    rclpy.init(args=args)
    node = RobotA1Node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
