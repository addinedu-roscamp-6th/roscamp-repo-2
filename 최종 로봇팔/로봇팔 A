import os, time, threading, socket, sys
import cv2
import numpy as np

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32, Bool
from flask import Flask, Response
from pymycobot.mycobot280 import MyCobot280

# â”€â”€ ê°„ë‹¨ ì›¹ë·°: ìµœì‹  í”„ë ˆì„ ìŠ¤íŠ¸ë¦¬ë° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app = Flask(__name__)
_latest_frame = None
_frame_lock = threading.Lock()

@app.route('/')
def index():
    return "<h1>JetCobot A - Camera</h1><div><img src='/video_feed'></div>"

@app.route('/video_feed')
def video_feed():
    def gen():
        while True:
            with _frame_lock:
                fr = None if _latest_frame is None else _latest_frame.copy()
            if fr is None:
                time.sleep(0.03)
                continue
            h, w = fr.shape[:2]
            cv2.drawMarker(fr, (w//2, h//2), (0,255,0), cv2.MARKER_CROSS, 20, 2)
            ok, jpg = cv2.imencode('.jpg', fr)
            if ok:
                yield (b'--frame\r\nContent-Type:image/jpeg\r\n\r\n' +
                       jpg.tobytes() + b'\r\n')
            time.sleep(0.03)
    return Response(gen(), mimetype='multipart/x-mixed-replace;boundary=frame')

def start_web():
    def local_ip():
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 9816))
            ip = s.getsockname()[0]; s.close(); return ip
        except Exception:
            return "127.0.0.1"
    threading.Thread(
        target=lambda: app.run(host='0.0.0.0', port=9816, debug=False, use_reloader=False, threaded=True),
        daemon=True
    ).start()
    print(f"ğŸŒ ì¹´ë©”ë¼ ë¯¸ë¦¬ë³´ê¸°: http://{local_ip()}:9816")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class RobotA1Node(Node):
    def __init__(self):
        super().__init__('robot_a_1_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # HW
        self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
        self.mc.thread_lock = True
        self.get_logger().info("ğŸ¤– JetCobot A ì—°ê²° ì™„ë£Œ")

        # ìƒíƒœ
        self.step_running = threading.Event()
        self.waiting_barrier = False
        self.executing_step = None
        self.pending_step = None
        self.last_step_time = None
        self.worker_thread = None
        self.step_done = False

        # ì¼ì‹œì •ì§€ í”Œë˜ê·¸
        self._pause_event = threading.Event()

        # Pub/Sub
        self.done_pub = self.create_publisher(Int32, '/a_1_done', self.qos1)
        self.ready_pub = self.create_publisher(Int32, '/a_ready_step', self.qos1)
        self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, self.qos1)
        self.create_subscription(Int32, '/go_step', self.go_callback, self.qos1)

        # â¬‡ï¸ ì¶”ê°€: ì¼ì‹œì •ì§€/ì¤€ë¹„ìì„¸ ëª…ë ¹ êµ¬ë…
        self.create_subscription(Bool, '/a_pause', self.pause_callback, self.qos1)
        self.create_subscription(Bool, '/a_move_ready', self.move_ready_callback, self.qos1)

        # íƒ€ì´ë¨¸
        self.create_timer(0.3, self.tick_timeout)

        # â”€â”€ ë¹„ì „/ì´ë™ íŒŒë¼ë¯¸í„°
        self.DT = np.array([36.38920224272615, -59.19202261629651, -116.73972075865049], float)
        self.CAM_MTX = np.array([[2736.98231, 0.0, 320.553729],
                                 [0.0, 2730.38853, 234.335302],
                                 [0.0, 0.0, 1.0]])
        self.DIST_COEFFS = np.array([[-2.09578526, -43.8402559, -0.0176765795, -0.0463219652, 511.115001]])
        self.MARKER_LEN = 5.0
        self.T_TOOL2CAM = np.array([0.0, 0.0, 0.0])   # ë°˜ë“œì‹œ ì¡´ì¬

        self.FAST_SPEED = 50
        self.SLOW_SPEED = 12
        self.BLEND_MODE = 1

        # ê¸°ì¡´ ê¸°ë³¸ í¬ì¦ˆ (CODE1 ì‹œ ì‚¬ìš©)
        self.BASIC_POSE = [0, 55, -90, -55, 6, -45]
        # â¬‡ï¸ ì¤€ë¹„ ìì„¸(ìš”ì²­ê°’)
        self.READY_POSE = [0, 0, -70, -20, 0, 45, 100]

        # ë™ì‘ ë§µ (101/201: ì´ë™ í›„ ë§ˆì»¤ 1ì´ˆ ì•ˆì • ëŒ€ê¸°)
        self.action_map = {
            101: [10, 0, 0, -70, 6, -45, 100],
            102: "CODE1",
            103: [0, 40, -130, 0, -60, 45, 100],
            104: [0, 40, -130, 0, 6, 45, 100],
            105: [0, 40, -130, 0, 6, 45, 0],
            106: [0, 0, -40, -48, 6, 45, 0],
            107: [0, -25, -65, 0, 6, 45, 0],
            108: [0, -25, -65, 0, 6, 45, 100],
            109: [0, 0, -40, -48, 6, 45, 100],
            110: "CODE1",
            111: [0, 40, -130, 0, -60, 45, 100],
            112: [0, 40, -130, 0, 6, 45, 100],
            113: [0, 40, -130, 0, 6, 45, 0],
            114: [0, 0, -40, -48, 6, 45, 0],
            115: [0, -25, -60, -5, 6, 45, 0],
            116: [0, -25, -60, -5, 6, 45, 100],
            117: [0, 0, -70, -20, 0, 45, 100],

            201: [0, -10, -45, -35, 6, -45, 100],
            202: [0, -20, -65, 0, -60, 45, 100],
            203: [0, -20, -65, 0, 6, 45, 100],
            204: [0, -20, -65, 0, 6, 45, 0],
            205: [0, 0, -40, -48, 6, 45, 0],
            206: [0, 40, -130, 0, 6, 45, 0],
            207: [0, 40, -130, 0, 6, 45, 100],
            208: [0, -25, -70, 8, -60, 45, 100],
            209: [0, -25, -70, 8, 6, 45, 100],
            210: [0, -25, -70, 8, 6, 45, 0],
            211: [0, 0, -40, -48, 6, 45, 0],
            212: [0, 40, -130, 0, 6, 45, 0],
            213: [0, 40, -130, 0, 6, 45, 100],
            214: [0, 0, -70, -20, 0, 45, 100],
        }

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¹´ë©”ë¼ í•­ìƒ ì¼œê¸° + ì‹¤ì‹œê°„ ë§ˆì»¤ ê²€ì¶œ ìƒíƒœ â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self._cap = cv2.VideoCapture(0)
        if self._cap.isOpened():
            self._cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self._cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            self._cap.set(cv2.CAP_PROP_FPS, 30)
            try:
                self._cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
            except Exception:
                pass
        else:
            self.get_logger().error("ì¹´ë©”ë¼ ì—´ê¸° ì‹¤íŒ¨(/dev/video0)")

        # ArUco ì¤€ë¹„
        self._aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_50)
        try:
            self._aruco_params = cv2.aruco.DetectorParameters()
        except Exception:
            self._aruco_params = cv2.aruco.DetectorParameters_create()

        # â”€â”€ ì•ˆì •ì„± íŒì • ìƒíƒœ (ì˜¤ì°¨ í—ˆìš© + íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ + ì €ì—­í†µê³¼)
        self._marker_lock = threading.Lock()
        self._marker_seen = False
        self._marker_last_rvec = None
        self._marker_last_tvec = None
        self._marker_anchor_t = None
        self._marker_anchor_ts = None

        self._pos_eps = 3.0
        self._pos_eps_reset = 8.0
        self._filter_alpha = 0.35
        self._tvec_filt = None

        self._stable_time_needed = 1.0

        # ì¹´ë©”ë¼ ìŠ¤ë ˆë“œ ì‹œì‘ + ì›¹ ì„œë²„
        self._cam_thread = threading.Thread(target=self._camera_loop, daemon=True)
        self._cam_thread.start()
        start_web()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¼ì‹œì •ì§€/ì¤€ë¹„ìì„¸ ì½œë°± â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def pause_callback(self, msg: Bool):
        if msg.data:
            self.get_logger().warn("â¸ ì¼ì‹œì •ì§€ ìˆ˜ì‹ : í˜„ì¬ ë™ì‘ ì •ì§€")
            self._pause_event.set()
            try:
                self.mc.stop()
            except Exception:
                pass
        else:
            self.get_logger().info("â–¶ ì¬ê°œ ìˆ˜ì‹ ")
            self._pause_event.clear()

    def move_ready_callback(self, msg: Bool):
        if msg.data:
            self.get_logger().info("ğŸŸ¦ ì¤€ë¹„ìì„¸ ì´ë™ ëª…ë ¹ ìˆ˜ì‹ ")
            threading.Thread(target=self._move_to_ready_safe, daemon=True).start()

    def _wait_if_paused(self):
        while self._pause_event.is_set():
            time.sleep(0.05)

    def _move_to_ready_safe(self):
        try:
            # ì¼ì‹œì •ì§€ ì¤‘ì—ë„ ì•ˆì „í•˜ê²Œ ì¤€ë¹„ìì„¸ë¡œ ì´ë™ (ì •ì§€ â†’ ì¤€ë¹„ìì„¸)
            try:
                self.mc.stop()
            except Exception:
                pass
            angles = self.READY_POSE[:6]
            grip = self.READY_POSE[6]
            self.mc.send_angles(angles, self.FAST_SPEED); time.sleep(0.6)
            self.mc.set_gripper_value(grip, 40); time.sleep(0.4)
            self.get_logger().info(f"âœ… ì¤€ë¹„ìì„¸ ì´ë™ ì™„ë£Œ: {self.READY_POSE}")
        except Exception as e:
            self.get_logger().error(f"âŒ ì¤€ë¹„ìì„¸ ì´ë™ ì‹¤íŒ¨: {e}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¹´ë©”ë¼ ë£¨í”„ (í•­ìƒ ì‹¤í–‰) â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _camera_loop(self):
        objp = np.array([
            [-self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
            [ self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
            [ self.MARKER_LEN/2, -self.MARKER_LEN/2, 0],
            [-self.MARKER_LEN/2, -self.MARKER_LEN/2, 0]
        ], dtype=np.float32)

        global _latest_frame, _frame_lock

        while True:
            ok, fr = self._cap.read()
            if not ok:
                time.sleep(0.02)
                continue

            gray = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)
            corners, ids, _ = cv2.aruco.detectMarkers(gray, self._aruco_dict, parameters=self._aruco_params)

            marker_on = False
            if ids is not None and len(corners) > 0:
                imgp = corners[0].reshape(-1, 2).astype(np.float32)
                ok_pnp, rvec, tvec = cv2.solvePnP(objp, imgp, self.CAM_MTX, self.DIST_COEFFS)
                if ok_pnp:
                    marker_on = True
                    t = tvec.flatten().astype(float)

                    # EMA í•„í„°
                    if self._tvec_filt is None:
                        self._tvec_filt = t.copy()
                    else:
                        self._tvec_filt = (1.0 - self._filter_alpha) * self._tvec_filt + self._filter_alpha * t
                    t_use = self._tvec_filt

                    with self._marker_lock:
                        # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤
                        if self._marker_anchor_t is None:
                            self._marker_anchor_t = t_use.copy()
                            self._marker_anchor_ts = time.time()
                        else:
                            dev = np.linalg.norm(t_use - self._marker_anchor_t)
                            if dev <= self._pos_eps:
                                pass
                            elif dev >= self._pos_eps_reset:
                                self._marker_anchor_t = t_use.copy()
                                self._marker_anchor_ts = time.time()
                            else:
                                pass

                        self._marker_seen = True
                        self._marker_last_rvec = rvec
                        self._marker_last_tvec = t_use.reshape(3, 1)

                    cv2.polylines(fr, [imgp.astype(int)], True, (0, 255, 255), 2)
                    try:
                        cv2.drawFrameAxes(fr, self.CAM_MTX, self.DIST_COEFFS, rvec, tvec, self.MARKER_LEN*0.7)
                    except Exception:
                        pass
            else:
                with self._marker_lock:
                    self._marker_seen = False
                    self._marker_anchor_t = None
                    self._marker_anchor_ts = None

            # ì¤‘ì•™ ì‹­ì & ìƒíƒœ
            h, w = fr.shape[:2]
            cv2.drawMarker(fr, (w//2, h//2), (0,255,0), cv2.MARKER_CROSS, 20, 2)
            with self._marker_lock:
                if self._marker_seen and self._marker_anchor_ts is not None:
                    stable_sec = time.time() - self._marker_anchor_ts
                else:
                    stable_sec = 0.0
            status = f"MARKER {'ON' if marker_on else 'OFF'} | stable={stable_sec:0.2f}s / need>= {self._stable_time_needed:.1f}s | epsâ‰¤{self._pos_eps:.1f}/{self._pos_eps_reset:.1f}"
            cv2.rectangle(fr, (0,0), (w, 30), (0,0,0), -1)
            cv2.putText(fr, status, (10,22), cv2.FONT_HERSHEY_SIMPLEX, 0.6,
                        (0,255,0) if marker_on else (0,0,255), 2, cv2.LINE_AA)

            with _frame_lock:
                _latest_frame = fr

            time.sleep(0.01)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ (ë°±ê·¸ë¼ìš´ë“œ) ë§ˆì»¤ ì•ˆì • ëŒ€ê¸° â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def wait_marker_stable(self, still_time=1.0, pos_eps=None, timeout=10.0):
        t0 = time.time()
        self._stable_time_needed = still_time
        old_eps = self._pos_eps
        if pos_eps is not None:
            self._pos_eps = float(pos_eps)
        try:
            while time.time() - t0 <= timeout:
                # ì¼ì‹œì •ì§€ ì¤‘ì—ëŠ” ì¹´ìš´íŠ¸ ì¤‘ë‹¨
                self._wait_if_paused()
                with self._marker_lock:
                    seen = self._marker_seen
                    t_anchor = self._marker_anchor_ts
                if seen and t_anchor is not None:
                    if time.time() - t_anchor >= still_time:
                        return True
                time.sleep(0.05)
            return False
        finally:
            self._pos_eps = old_eps

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìœ í‹¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @staticmethod
    def euler_to_R(rx, ry, rz):
        a, b, c = np.deg2rad([rx, ry, rz])
        cz, sz = np.cos(c), np.sin(c)
        cy, sy = np.cos(b), np.sin(b)
        cx, sx = np.cos(a), np.sin(a)
        Rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])
        Ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])
        Rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])
        return Rz @ Ry @ Rx

    @staticmethod
    def clamp(v, lo, hi): return lo if v < lo else (hi if v > hi else v)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ CODE1 í•µì‹¬ (ë°±ê·¸ë¼ìš´ë“œ ê²€ì¶œ ì‚¬ìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def to_marker_basic(self):
        self._wait_if_paused()
        ok = self.wait_marker_stable(still_time=1.0, pos_eps=None, timeout=20.0)
        if not ok:
            raise RuntimeError("ë§ˆì»¤ ì•ˆì • ëŒ€ê¸°(1.0s) ì‹¤íŒ¨")

        with self._marker_lock:
            rvec = None if self._marker_last_rvec is None else self._marker_last_rvec.copy()
            tvec = None if self._marker_last_tvec is None else self._marker_last_tvec.copy()
        if rvec is None or tvec is None:
            raise RuntimeError("ë§ˆì»¤ í¬ì¦ˆ ì—†ìŒ")

        tvec = tvec.flatten()
        tvec_fixed = np.array([ round(-tvec[1],1), round(-tvec[0],1), round(tvec[2],1) ])

        coords = self.mc.get_coords()
        if coords is None: raise RuntimeError("get_coords() ì‹¤íŒ¨")
        ori = [round(x,1) for x in coords[3:]]
        R_tool = self.euler_to_R(*ori)
        T_tool_in_base = np.round(R_tool @ self.T_TOOL2CAM, 1)

        marker_abs_pos = np.round(self.DT + tvec_fixed + T_tool_in_base, 1)
        current_coords = np.array(coords[:3])
        delta = marker_abs_pos - current_coords

        correction_offset = np.array([45.0, 0.0, 0.0])
        target_coords = current_coords + delta + correction_offset
        target_coords[2] = 170.0

        self._wait_if_paused()
        self.mc.send_coords(target_coords.tolist() + ori, speed=self.SLOW_SPEED, mode=self.BLEND_MODE)
        time.sleep(5)

        try:
            rmat, _ = cv2.Rodrigues(rvec)
            rz = np.degrees(np.arctan2(rmat[1,0], rmat[0,0]))
            rz = ((rz + 180) % 360) - 180
            rz_base = round(rz/90.0)*90
            rz_offset = round(rz - rz_base, 1)

            angles = self.mc.get_angles()
            if angles is None:
                self.get_logger().warn("J6 íšŒì „ ìŠ¤í‚µ: ê´€ì ˆ ê°ë„ ì½ê¸° ì‹¤íŒ¨")
            else:
                j6_saved = float(angles[5])
                j6_temp  = self.clamp(round(j6_saved + rz_offset, 1), -180.0, 180.0)

                self._wait_if_paused()
                self.mc.send_angle(6, j6_temp, self.SLOW_SPEED); time.sleep(1.2)

                self._wait_if_paused()
                self.mc.set_gripper_value(0, 50); time.sleep(0.5)

                self._wait_if_paused()
                self.mc.send_angle(6, j6_saved, self.SLOW_SPEED); time.sleep(1.0)
        except Exception as e:
            self.get_logger().warn(f"J6 ì¼ì‹œ íšŒì „/ë³µê·€ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")

        try:
            self._wait_if_paused()
            final_angles = [0, 40, -130, 0, 6, -45]
            self.mc.send_angles(final_angles, self.FAST_SPEED); time.sleep(0.7)

            self._wait_if_paused()
            self.mc.send_angle(5, 0, self.FAST_SPEED); time.sleep(0.5)

            self._wait_if_paused()
            self.mc.set_gripper_value(100, 50); time.sleep(0.5)

            self._wait_if_paused()
            self.mc.send_angle(6, 45, self.FAST_SPEED); time.sleep(0.5)

            self._wait_if_paused()
            self.mc.send_angle(5, -60, self.FAST_SPEED); time.sleep(0.5)

            self.get_logger().info("ğŸ“Œ ìµœì¢… ìì„¸ [0,40,-130,0,6,-45] â†’ J5=0 â†’ ê·¸ë¦¬í¼=100 â†’ J6=45 â†’ J5=-60 ì™„ë£Œ")
        except Exception as e:
            self.get_logger().error(f"ìµœì¢… ìì„¸ ì´ë™ ì‹¤íŒ¨: {e}")

    def run_code1_feature(self):
        self.get_logger().info("ğŸ§© ì½”ë“œ1 ê¸°ëŠ¥ ì‹¤í–‰ ì‹œì‘")
        self._wait_if_paused()
        self.mc.send_angles(self.BASIC_POSE, self.FAST_SPEED); time.sleep(0.5)
        self._wait_if_paused()
        self.mc.set_gripper_value(100, 50); time.sleep(0.3)
        self._wait_if_paused()
        self.to_marker_basic()
        self.get_logger().info("ğŸ§© ì½”ë“œ1 ê¸°ëŠ¥ ì™„ë£Œ")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë°°ë¦¬ì–´ í”„ë¡œí† ì½œ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def step_callback(self, msg):
        step = int(msg.data)
        if self.step_running.is_set() or self.waiting_barrier:
            if step != self.executing_step:
                self.pending_step = step
                self.get_logger().warn(f"ğŸ§º ì‹¤í–‰/ëŒ€ê¸° ì¤‘({self.executing_step}) â†’ Step {step} íì‰")
            return

        self.executing_step = step
        self.step_done = False
        self.last_step_time = time.time()
        self.waiting_barrier = True
        self.ready_pub.publish(Int32(data=step))
        self.get_logger().info(f"ğŸŸ¡ READY ì „ì†¡: {step} (GO ëŒ€ê¸°)")

    def go_callback(self, msg):
        go = int(msg.data)
        if self.waiting_barrier and go == self.executing_step:
            self.waiting_barrier = False
            self.step_running.set()
            if (go in self.action_map and self.action_map[go] == "CODE1"):
                self.worker_thread = threading.Thread(target=self.execute_code1_step, args=(go,), daemon=True)
            else:
                self.worker_thread = threading.Thread(target=self.execute_step, args=(go,), daemon=True)
            self.worker_thread.start()

    def execute_code1_step(self, step):
        try:
            self.run_code1_feature()
            self.step_done = True
            self.get_logger().info(f"âœ… Step {step} (CODE1) ì™„ë£Œ")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"âŒ Step {step} (CODE1) ì‹¤íŒ¨: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def execute_step(self, step):
        angles = self.action_map[step]
        try:
            self._wait_if_paused()
            self.mc.send_angles(angles[:6], 30)

            self._wait_if_paused()
            self.mc.set_gripper_value(angles[6], 30)

            if step in (101, 201):
                self.get_logger().info(f"ğŸ” Step {step}: ë§ˆì»¤ 1.0s ì•ˆì • ëŒ€ê¸° ì‹œì‘")
                ok = self.wait_marker_stable(still_time=1.0, pos_eps=None, timeout=15.0)
                if ok:
                    self.get_logger().info(f"âœ… Step {step}: ë§ˆì»¤ 1.0s ì•ˆì • í™•ì¸")
                else:
                    self.get_logger().warn(f"âš ï¸ Step {step}: ë§ˆì»¤ ì•ˆì • ëŒ€ê¸° íƒ€ì„ì•„ì›ƒ(15s)")

            time.sleep(2)
            self.step_done = True
            self.get_logger().info(f"âœ… Step {step} ì™„ë£Œ")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"âŒ Step {step} ì‹¤íŒ¨: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def tick_timeout(self):
        if self.waiting_barrier and self.executing_step is not None:
            if time.time() - self.last_step_time > 3.0:
                self.ready_pub.publish(Int32(data=int(self.executing_step)))
                self.last_step_time = time.time()
                self.get_logger().warn(f"â³ READY ì¬ì „ì†¡: {self.executing_step}")

def main(args=None):
    try:
        cv2.utils.logging.setLogLevel(cv2.utils.logging.LOG_LEVEL_SILENT)
    except Exception:
        pass

    rclpy.init(args=args)
    node = RobotA1Node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
