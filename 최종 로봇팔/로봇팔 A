import os, time, threading, socket, sys
import cv2
import numpy as np

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32, Bool
from flask import Flask, Response
from pymycobot.mycobot280 import MyCobot280

# ── 간단 웹뷰: 최신 프레임 스트리밍 ─────────────────────────────
app = Flask(__name__)
_latest_frame = None
_frame_lock = threading.Lock()

@app.route('/')
def index():
    return "<h1>JetCobot A - Camera</h1><div><img src='/video_feed'></div>"

@app.route('/video_feed')
def video_feed():
    def gen():
        while True:
            with _frame_lock:
                fr = None if _latest_frame is None else _latest_frame.copy()
            if fr is None:
                time.sleep(0.03)
                continue
            h, w = fr.shape[:2]
            cv2.drawMarker(fr, (w//2, h//2), (0,255,0), cv2.MARKER_CROSS, 20, 2)
            ok, jpg = cv2.imencode('.jpg', fr)
            if ok:
                yield (b'--frame\r\nContent-Type:image/jpeg\r\n\r\n' +
                       jpg.tobytes() + b'\r\n')
            time.sleep(0.03)
    return Response(gen(), mimetype='multipart/x-mixed-replace;boundary=frame')

def start_web():
    def local_ip():
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 9816))
            ip = s.getsockname()[0]; s.close(); return ip
        except Exception:
            return "127.0.0.1"
    threading.Thread(
        target=lambda: app.run(host='0.0.0.0', port=9816, debug=False, use_reloader=False, threaded=True),
        daemon=True
    ).start()
    print(f"🌐 카메라 미리보기: http://{local_ip()}:9816")

# ──────────────────────────────────────────────────────────────────

class RobotA1Node(Node):
    def __init__(self):
        super().__init__('robot_a_1_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # HW
        self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
        self.mc.thread_lock = True
        self.get_logger().info("🤖 JetCobot A 연결 완료")

        # 상태
        self.step_running = threading.Event()
        self.waiting_barrier = False
        self.executing_step = None
        self.pending_step = None
        self.last_step_time = None
        self.worker_thread = None
        self.step_done = False

        # 일시정지 플래그
        self._pause_event = threading.Event()

        # Pub/Sub
        self.done_pub = self.create_publisher(Int32, '/a_1_done', self.qos1)
        self.ready_pub = self.create_publisher(Int32, '/a_ready_step', self.qos1)
        self.create_subscription(Int32, '/robot_a_1_node', self.step_callback, self.qos1)
        self.create_subscription(Int32, '/go_step', self.go_callback, self.qos1)

        # ⬇️ 추가: 일시정지/준비자세 명령 구독
        self.create_subscription(Bool, '/a_pause', self.pause_callback, self.qos1)
        self.create_subscription(Bool, '/a_move_ready', self.move_ready_callback, self.qos1)

        # 타이머
        self.create_timer(0.3, self.tick_timeout)

        # ── 비전/이동 파라미터
        self.DT = np.array([36.38920224272615, -59.19202261629651, -116.73972075865049], float)
        self.CAM_MTX = np.array([[2736.98231, 0.0, 320.553729],
                                 [0.0, 2730.38853, 234.335302],
                                 [0.0, 0.0, 1.0]])
        self.DIST_COEFFS = np.array([[-2.09578526, -43.8402559, -0.0176765795, -0.0463219652, 511.115001]])
        self.MARKER_LEN = 5.0
        self.T_TOOL2CAM = np.array([0.0, 0.0, 0.0])   # 반드시 존재

        self.FAST_SPEED = 50
        self.SLOW_SPEED = 12
        self.BLEND_MODE = 1

        # 기존 기본 포즈 (CODE1 시 사용)
        self.BASIC_POSE = [0, 55, -90, -55, 6, -45]
        # ⬇️ 준비 자세(요청값)
        self.READY_POSE = [0, 0, -70, -20, 0, 45, 100]

        # 동작 맵 (101/201: 이동 후 마커 1초 안정 대기)
        self.action_map = {
            101: [10, 0, 0, -70, 6, -45, 100],
            102: "CODE1",
            103: [0, 40, -130, 0, -60, 45, 100],
            104: [0, 40, -130, 0, 6, 45, 100],
            105: [0, 40, -130, 0, 6, 45, 0],
            106: [0, 0, -40, -48, 6, 45, 0],
            107: [0, -25, -65, 0, 6, 45, 0],
            108: [0, -25, -65, 0, 6, 45, 100],
            109: [0, 0, -40, -48, 6, 45, 100],
            110: "CODE1",
            111: [0, 40, -130, 0, -60, 45, 100],
            112: [0, 40, -130, 0, 6, 45, 100],
            113: [0, 40, -130, 0, 6, 45, 0],
            114: [0, 0, -40, -48, 6, 45, 0],
            115: [0, -25, -60, -5, 6, 45, 0],
            116: [0, -25, -60, -5, 6, 45, 100],
            117: [0, 0, -70, -20, 0, 45, 100],

            201: [0, -10, -45, -35, 6, -45, 100],
            202: [0, -20, -65, 0, -60, 45, 100],
            203: [0, -20, -65, 0, 6, 45, 100],
            204: [0, -20, -65, 0, 6, 45, 0],
            205: [0, 0, -40, -48, 6, 45, 0],
            206: [0, 40, -130, 0, 6, 45, 0],
            207: [0, 40, -130, 0, 6, 45, 100],
            208: [0, -25, -70, 8, -60, 45, 100],
            209: [0, -25, -70, 8, 6, 45, 100],
            210: [0, -25, -70, 8, 6, 45, 0],
            211: [0, 0, -40, -48, 6, 45, 0],
            212: [0, 40, -130, 0, 6, 45, 0],
            213: [0, 40, -130, 0, 6, 45, 100],
            214: [0, 0, -70, -20, 0, 45, 100],
        }

        # ───────── 카메라 항상 켜기 + 실시간 마커 검출 상태 ─────────
        self._cap = cv2.VideoCapture(0)
        if self._cap.isOpened():
            self._cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self._cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            self._cap.set(cv2.CAP_PROP_FPS, 30)
            try:
                self._cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
            except Exception:
                pass
        else:
            self.get_logger().error("카메라 열기 실패(/dev/video0)")

        # ArUco 준비
        self._aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_50)
        try:
            self._aruco_params = cv2.aruco.DetectorParameters()
        except Exception:
            self._aruco_params = cv2.aruco.DetectorParameters_create()

        # ── 안정성 판정 상태 (오차 허용 + 히스테리시스 + 저역통과)
        self._marker_lock = threading.Lock()
        self._marker_seen = False
        self._marker_last_rvec = None
        self._marker_last_tvec = None
        self._marker_anchor_t = None
        self._marker_anchor_ts = None

        self._pos_eps = 3.0
        self._pos_eps_reset = 8.0
        self._filter_alpha = 0.35
        self._tvec_filt = None

        self._stable_time_needed = 1.0

        # 카메라 스레드 시작 + 웹 서버
        self._cam_thread = threading.Thread(target=self._camera_loop, daemon=True)
        self._cam_thread.start()
        start_web()

    # ───────── 일시정지/준비자세 콜백 ─────────
    def pause_callback(self, msg: Bool):
        if msg.data:
            self.get_logger().warn("⏸ 일시정지 수신: 현재 동작 정지")
            self._pause_event.set()
            try:
                self.mc.stop()
            except Exception:
                pass
        else:
            self.get_logger().info("▶ 재개 수신")
            self._pause_event.clear()

    def move_ready_callback(self, msg: Bool):
        if msg.data:
            self.get_logger().info("🟦 준비자세 이동 명령 수신")
            threading.Thread(target=self._move_to_ready_safe, daemon=True).start()

    def _wait_if_paused(self):
        while self._pause_event.is_set():
            time.sleep(0.05)

    def _move_to_ready_safe(self):
        try:
            # 일시정지 중에도 안전하게 준비자세로 이동 (정지 → 준비자세)
            try:
                self.mc.stop()
            except Exception:
                pass
            angles = self.READY_POSE[:6]
            grip = self.READY_POSE[6]
            self.mc.send_angles(angles, self.FAST_SPEED); time.sleep(0.6)
            self.mc.set_gripper_value(grip, 40); time.sleep(0.4)
            self.get_logger().info(f"✅ 준비자세 이동 완료: {self.READY_POSE}")
        except Exception as e:
            self.get_logger().error(f"❌ 준비자세 이동 실패: {e}")

    # ───────── 카메라 루프 (항상 실행) ─────────
    def _camera_loop(self):
        objp = np.array([
            [-self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
            [ self.MARKER_LEN/2,  self.MARKER_LEN/2, 0],
            [ self.MARKER_LEN/2, -self.MARKER_LEN/2, 0],
            [-self.MARKER_LEN/2, -self.MARKER_LEN/2, 0]
        ], dtype=np.float32)

        global _latest_frame, _frame_lock

        while True:
            ok, fr = self._cap.read()
            if not ok:
                time.sleep(0.02)
                continue

            gray = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)
            corners, ids, _ = cv2.aruco.detectMarkers(gray, self._aruco_dict, parameters=self._aruco_params)

            marker_on = False
            if ids is not None and len(corners) > 0:
                imgp = corners[0].reshape(-1, 2).astype(np.float32)
                ok_pnp, rvec, tvec = cv2.solvePnP(objp, imgp, self.CAM_MTX, self.DIST_COEFFS)
                if ok_pnp:
                    marker_on = True
                    t = tvec.flatten().astype(float)

                    # EMA 필터
                    if self._tvec_filt is None:
                        self._tvec_filt = t.copy()
                    else:
                        self._tvec_filt = (1.0 - self._filter_alpha) * self._tvec_filt + self._filter_alpha * t
                    t_use = self._tvec_filt

                    with self._marker_lock:
                        # 히스테리시스
                        if self._marker_anchor_t is None:
                            self._marker_anchor_t = t_use.copy()
                            self._marker_anchor_ts = time.time()
                        else:
                            dev = np.linalg.norm(t_use - self._marker_anchor_t)
                            if dev <= self._pos_eps:
                                pass
                            elif dev >= self._pos_eps_reset:
                                self._marker_anchor_t = t_use.copy()
                                self._marker_anchor_ts = time.time()
                            else:
                                pass

                        self._marker_seen = True
                        self._marker_last_rvec = rvec
                        self._marker_last_tvec = t_use.reshape(3, 1)

                    cv2.polylines(fr, [imgp.astype(int)], True, (0, 255, 255), 2)
                    try:
                        cv2.drawFrameAxes(fr, self.CAM_MTX, self.DIST_COEFFS, rvec, tvec, self.MARKER_LEN*0.7)
                    except Exception:
                        pass
            else:
                with self._marker_lock:
                    self._marker_seen = False
                    self._marker_anchor_t = None
                    self._marker_anchor_ts = None

            # 중앙 십자 & 상태
            h, w = fr.shape[:2]
            cv2.drawMarker(fr, (w//2, h//2), (0,255,0), cv2.MARKER_CROSS, 20, 2)
            with self._marker_lock:
                if self._marker_seen and self._marker_anchor_ts is not None:
                    stable_sec = time.time() - self._marker_anchor_ts
                else:
                    stable_sec = 0.0
            status = f"MARKER {'ON' if marker_on else 'OFF'} | stable={stable_sec:0.2f}s / need>= {self._stable_time_needed:.1f}s | eps≤{self._pos_eps:.1f}/{self._pos_eps_reset:.1f}"
            cv2.rectangle(fr, (0,0), (w, 30), (0,0,0), -1)
            cv2.putText(fr, status, (10,22), cv2.FONT_HERSHEY_SIMPLEX, 0.6,
                        (0,255,0) if marker_on else (0,0,255), 2, cv2.LINE_AA)

            with _frame_lock:
                _latest_frame = fr

            time.sleep(0.01)

    # ───────── (백그라운드) 마커 안정 대기 ─────────
    def wait_marker_stable(self, still_time=1.0, pos_eps=None, timeout=10.0):
        t0 = time.time()
        self._stable_time_needed = still_time
        old_eps = self._pos_eps
        if pos_eps is not None:
            self._pos_eps = float(pos_eps)
        try:
            while time.time() - t0 <= timeout:
                # 일시정지 중에는 카운트 중단
                self._wait_if_paused()
                with self._marker_lock:
                    seen = self._marker_seen
                    t_anchor = self._marker_anchor_ts
                if seen and t_anchor is not None:
                    if time.time() - t_anchor >= still_time:
                        return True
                time.sleep(0.05)
            return False
        finally:
            self._pos_eps = old_eps

    # ───────── 유틸 ─────────
    @staticmethod
    def euler_to_R(rx, ry, rz):
        a, b, c = np.deg2rad([rx, ry, rz])
        cz, sz = np.cos(c), np.sin(c)
        cy, sy = np.cos(b), np.sin(b)
        cx, sx = np.cos(a), np.sin(a)
        Rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])
        Ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])
        Rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])
        return Rz @ Ry @ Rx

    @staticmethod
    def clamp(v, lo, hi): return lo if v < lo else (hi if v > hi else v)

    # ───────── CODE1 핵심 (백그라운드 검출 사용) ─────────
    def to_marker_basic(self):
        self._wait_if_paused()
        ok = self.wait_marker_stable(still_time=1.0, pos_eps=None, timeout=20.0)
        if not ok:
            raise RuntimeError("마커 안정 대기(1.0s) 실패")

        with self._marker_lock:
            rvec = None if self._marker_last_rvec is None else self._marker_last_rvec.copy()
            tvec = None if self._marker_last_tvec is None else self._marker_last_tvec.copy()
        if rvec is None or tvec is None:
            raise RuntimeError("마커 포즈 없음")

        tvec = tvec.flatten()
        tvec_fixed = np.array([ round(-tvec[1],1), round(-tvec[0],1), round(tvec[2],1) ])

        coords = self.mc.get_coords()
        if coords is None: raise RuntimeError("get_coords() 실패")
        ori = [round(x,1) for x in coords[3:]]
        R_tool = self.euler_to_R(*ori)
        T_tool_in_base = np.round(R_tool @ self.T_TOOL2CAM, 1)

        marker_abs_pos = np.round(self.DT + tvec_fixed + T_tool_in_base, 1)
        current_coords = np.array(coords[:3])
        delta = marker_abs_pos - current_coords

        correction_offset = np.array([45.0, 0.0, 0.0])
        target_coords = current_coords + delta + correction_offset
        target_coords[2] = 170.0

        self._wait_if_paused()
        self.mc.send_coords(target_coords.tolist() + ori, speed=self.SLOW_SPEED, mode=self.BLEND_MODE)
        time.sleep(5)

        try:
            rmat, _ = cv2.Rodrigues(rvec)
            rz = np.degrees(np.arctan2(rmat[1,0], rmat[0,0]))
            rz = ((rz + 180) % 360) - 180
            rz_base = round(rz/90.0)*90
            rz_offset = round(rz - rz_base, 1)

            angles = self.mc.get_angles()
            if angles is None:
                self.get_logger().warn("J6 회전 스킵: 관절 각도 읽기 실패")
            else:
                j6_saved = float(angles[5])
                j6_temp  = self.clamp(round(j6_saved + rz_offset, 1), -180.0, 180.0)

                self._wait_if_paused()
                self.mc.send_angle(6, j6_temp, self.SLOW_SPEED); time.sleep(1.2)

                self._wait_if_paused()
                self.mc.set_gripper_value(0, 50); time.sleep(0.5)

                self._wait_if_paused()
                self.mc.send_angle(6, j6_saved, self.SLOW_SPEED); time.sleep(1.0)
        except Exception as e:
            self.get_logger().warn(f"J6 일시 회전/복귀 처리 실패: {e}")

        try:
            self._wait_if_paused()
            final_angles = [0, 40, -130, 0, 6, -45]
            self.mc.send_angles(final_angles, self.FAST_SPEED); time.sleep(0.7)

            self._wait_if_paused()
            self.mc.send_angle(5, 0, self.FAST_SPEED); time.sleep(0.5)

            self._wait_if_paused()
            self.mc.set_gripper_value(100, 50); time.sleep(0.5)

            self._wait_if_paused()
            self.mc.send_angle(6, 45, self.FAST_SPEED); time.sleep(0.5)

            self._wait_if_paused()
            self.mc.send_angle(5, -60, self.FAST_SPEED); time.sleep(0.5)

            self.get_logger().info("📌 최종 자세 [0,40,-130,0,6,-45] → J5=0 → 그리퍼=100 → J6=45 → J5=-60 완료")
        except Exception as e:
            self.get_logger().error(f"최종 자세 이동 실패: {e}")

    def run_code1_feature(self):
        self.get_logger().info("🧩 코드1 기능 실행 시작")
        self._wait_if_paused()
        self.mc.send_angles(self.BASIC_POSE, self.FAST_SPEED); time.sleep(0.5)
        self._wait_if_paused()
        self.mc.set_gripper_value(100, 50); time.sleep(0.3)
        self._wait_if_paused()
        self.to_marker_basic()
        self.get_logger().info("🧩 코드1 기능 완료")

    # ───────── 배리어 프로토콜 ─────────
    def step_callback(self, msg):
        step = int(msg.data)
        if self.step_running.is_set() or self.waiting_barrier:
            if step != self.executing_step:
                self.pending_step = step
                self.get_logger().warn(f"🧺 실행/대기 중({self.executing_step}) → Step {step} 큐잉")
            return

        self.executing_step = step
        self.step_done = False
        self.last_step_time = time.time()
        self.waiting_barrier = True
        self.ready_pub.publish(Int32(data=step))
        self.get_logger().info(f"🟡 READY 전송: {step} (GO 대기)")

    def go_callback(self, msg):
        go = int(msg.data)
        if self.waiting_barrier and go == self.executing_step:
            self.waiting_barrier = False
            self.step_running.set()
            if (go in self.action_map and self.action_map[go] == "CODE1"):
                self.worker_thread = threading.Thread(target=self.execute_code1_step, args=(go,), daemon=True)
            else:
                self.worker_thread = threading.Thread(target=self.execute_step, args=(go,), daemon=True)
            self.worker_thread.start()

    def execute_code1_step(self, step):
        try:
            self.run_code1_feature()
            self.step_done = True
            self.get_logger().info(f"✅ Step {step} (CODE1) 완료")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"❌ Step {step} (CODE1) 실패: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def execute_step(self, step):
        angles = self.action_map[step]
        try:
            self._wait_if_paused()
            self.mc.send_angles(angles[:6], 30)

            self._wait_if_paused()
            self.mc.set_gripper_value(angles[6], 30)

            if step in (101, 201):
                self.get_logger().info(f"🔍 Step {step}: 마커 1.0s 안정 대기 시작")
                ok = self.wait_marker_stable(still_time=1.0, pos_eps=None, timeout=15.0)
                if ok:
                    self.get_logger().info(f"✅ Step {step}: 마커 1.0s 안정 확인")
                else:
                    self.get_logger().warn(f"⚠️ Step {step}: 마커 안정 대기 타임아웃(15s)")

            time.sleep(2)
            self.step_done = True
            self.get_logger().info(f"✅ Step {step} 완료")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"❌ Step {step} 실패: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def tick_timeout(self):
        if self.waiting_barrier and self.executing_step is not None:
            if time.time() - self.last_step_time > 3.0:
                self.ready_pub.publish(Int32(data=int(self.executing_step)))
                self.last_step_time = time.time()
                self.get_logger().warn(f"⏳ READY 재전송: {self.executing_step}")

def main(args=None):
    try:
        cv2.utils.logging.setLogLevel(cv2.utils.logging.LOG_LEVEL_SILENT)
    except Exception:
        pass

    rclpy.init(args=args)
    node = RobotA1Node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
