import time
import threading

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32, Bool
from pymycobot.mycobot280 import MyCobot280

class RobotB1Node(Node):
    def __init__(self):
        super().__init__('robot_b_1_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # HW
        self.mc = MyCobot280('/dev/ttyJETCOBOT', 1000000)
        self.mc.thread_lock = True
        self.get_logger().info("ü§ñ JetCobot B Ïó∞Í≤∞ ÏôÑÎ£å")

        # ÏÉÅÌÉú
        self.step_running = threading.Event()
        self.waiting_barrier = False
        self.executing_step = None
        self.pending_step = None
        self.last_step_time = None
        self.worker_thread = None
        self.step_done = False

        # ÏùºÏãúÏ†ïÏßÄ/Î≥µÍµ¨ ÏÉÅÌÉú
        self._pause_event = threading.Event()
        self._resume_lock = threading.Lock()
        self._last_cmd = None
        self._need_resume = False

        # Pub/Sub
        self.done_pub = self.create_publisher(Int32, '/b_1_done', self.qos1)
        self.ready_pub = self.create_publisher(Int32, '/b_ready_step', self.qos1)
        self.create_subscription(Int32, '/robot_b_1_node', self.step_callback, self.qos1)
        self.create_subscription(Int32, '/go_step', self.go_callback, self.qos1)
        self.create_subscription(Bool, '/b_pause', self.pause_callback, self.qos1)
        self.create_subscription(Bool, '/b_move_ready', self.move_ready_callback, self.qos1)

        # ÌÉÄÏù¥Î®∏
        self.create_timer(0.3, self.tick_timeout)

        # ÌååÎùºÎØ∏ÌÑ∞
        self.FAST_SPEED = 50
        self.SLOW_SPEED = 12

        # ÏûêÏÑ∏
        self.READY_POSE = [0, 0, -70, -20, 0, 45, 100]
        self.BASIC_POSE = [0, 55, -90, -55, 6, -45]

        # ÎèôÏûë Îßµ (Í∑∏ÎåÄÎ°ú)
        self.action_map = {
            101: [10, 0, 0, -70, 6, -45, 100],
            102: "CODE1",
            103: [0, 40, -130, 0, -60, 45, 100],
            104: [0, 40, -130, 0, 6, 45, 100],
            105: [0, 40, -130, 0, 6, 45, 0],
            106: [0, 0, -40, -48, 6, 45, 0],
            107: [0, -25, -65, 0, 6, 45, 0],
            108: [0, -25, -65, 0, 6, 45, 100],
            109: [0, 0, -40, -48, 6, 45, 100],
            110: "CODE1",
            111: [0, 40, -130, 0, -60, 45, 100],
            112: [0, 40, -130, 0, 6, 45, 100],
            113: [0, 40, -130, 0, 6, 45, 0],
            114: [0, 0, -40, -48, 6, 45, 0],
            115: [0, -25, -60, -5, 6, 45, 0],
            116: [0, -25, -60, -5, 6, 45, 100],
            117: [0, 0, -70, -20, 0, 45, 100],
            201: [0, -10, -45, -35, 6, -45, 100],
            202: [0, -20, -65, 0, -60, 45, 100],
            203: [0, -20, -65, 0, 6, 45, 100],
            204: [0, -20, -65, 0, 6, 45, 0],
            205: [0, 0, -40, -48, 6, 45, 0],
            206: [0, 40, -130, 0, 6, 45, 0],
            207: [0, 40, -130, 0, 6, 45, 100],
            208: [0, -25, -70, 8, -60, 45, 100],
            209: [0, -25, -70, 8, 6, 45, 100],
            210: [0, -25, -70, 8, 6, 45, 0],
            211: [0, 0, -40, -48, 6, 45, 0],
            212: [0, 40, -130, 0, 6, 45, 0],
            213: [0, 40, -130, 0, 6, 45, 100],
            214: [0, 0, -70, -20, 0, 45, 100],
        }

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ ÎûòÌçº ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _ckpt_send_angles(self, angles, speed, save=True):
        if save:
            with self._resume_lock:
                self._last_cmd = ("angles", angles[:], speed, None)
        self.mc.send_angles(angles, speed)

    def _ckpt_send_angle(self, joint_index, degree, speed, save=True):
        if save:
            with self._resume_lock:
                self._last_cmd = ("angle", int(joint_index), float(degree), speed)
        self.mc.send_angle(joint_index, degree, speed)

    def _ckpt_send_coords(self, coords6, speed, mode, save=True):
        if save:
            with self._resume_lock:
                self._last_cmd = ("coords", coords6[:], speed, mode)
        self.mc.send_coords(coords6, speed, mode)

    def _ckpt_set_gripper(self, value, speed, save=True):
        if save:
            with self._resume_lock:
                self._last_cmd = ("gripper", int(value), speed, None)
        self.mc.set_gripper_value(value, speed)

    def _reissue_last_cmd_if_needed(self):
        with self._resume_lock:
            if not self._need_resume or self._last_cmd is None:
                return
            kind, a, b, c = self._last_cmd
            try:
                if kind == "angles":
                    self.mc.send_angles(a, b)
                elif kind == "angle":
                    self.mc.send_angle(a, b, c)
                elif kind == "coords":
                    self.mc.send_coords(a, b, c)
                elif kind == "gripper":
                    self.mc.set_gripper_value(a, b)
                self.get_logger().info(f"‚Üª (B) ÏùºÏãúÏ†ïÏßÄ Î≥µÍµ¨: ÎßàÏßÄÎßâ Î™ÖÎ†π Ïû¨Ï†ÑÏÜ°({kind})")
            except Exception as e:
                self.get_logger().warn(f"(B) Î≥µÍµ¨ Ï§ë Ïû¨Ï†ÑÏÜ° Ïã§Ìå®: {e}")
            finally:
                self._need_resume = False

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÏùºÏãúÏ†ïÏßÄ/Ï§ÄÎπÑÏûêÏÑ∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def pause_callback(self, msg: Bool):
        if msg.data:
            self.get_logger().warn("‚è∏ (B) ÏùºÏãúÏ†ïÏßÄ ÏàòÏã†: ÌòÑÏû¨ ÎèôÏûë Ï†ïÏßÄ")
            self._pause_event.set()
            try: self.mc.stop()
            except Exception: pass
            with self._resume_lock:
                self._need_resume = True
        else:
            self.get_logger().info("‚ñ∂ (B) Ïû¨Í∞ú ÏàòÏã†")
            self._pause_event.clear()

    def move_ready_callback(self, msg: Bool):
        if msg.data:
            self.get_logger().info("üü¶ (B) Ï§ÄÎπÑÏûêÏÑ∏ Ïù¥Îèô Î™ÖÎ†π ÏàòÏã†")
            threading.Thread(target=self._move_to_ready_safe, daemon=True).start()

    def _wait_if_paused(self):
        while self._pause_event.is_set():
            time.sleep(0.05)
        self._reissue_last_cmd_if_needed()

    def _move_to_ready_safe(self):
        try:
            try: self.mc.stop()
            except Exception: pass
            angles = self.READY_POSE[:6]
            grip = self.READY_POSE[6]
            self._ckpt_send_angles(angles, self.FAST_SPEED, save=False); time.sleep(0.6)
            self._ckpt_set_gripper(grip, 40, save=False); time.sleep(0.4)
            self.get_logger().info(f"‚úÖ (B) Ï§ÄÎπÑÏûêÏÑ∏ Ïù¥Îèô ÏôÑÎ£å: {self.READY_POSE}")
        except Exception as e:
            self.get_logger().error(f"‚ùå (B) Ï§ÄÎπÑÏûêÏÑ∏ Ïù¥Îèô Ïã§Ìå®: {e}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Î∞∞Î¶¨Ïñ¥/Ïä§ÌÖù(Í∑∏ÎåÄÎ°ú) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def step_callback(self, msg):
        step = int(msg.data)
        if self.step_running.is_set() or self.waiting_barrier:
            if step != self.executing_step:
                self.pending_step = step
                self.get_logger().warn(f"üß∫ (B) Ïã§Ìñâ/ÎåÄÍ∏∞ Ï§ë({self.executing_step}) ‚Üí Step {step} ÌÅêÏûâ")
            return
        self.executing_step = step
        self.step_done = False
        self.last_step_time = time.time()
        self.waiting_barrier = True
        self.ready_pub.publish(Int32(data=step))
        self.get_logger().info(f"üü° (B) READY Ï†ÑÏÜ°: {step} (GO ÎåÄÍ∏∞)")

    def go_callback(self, msg):
        go = int(msg.data)
        if self.waiting_barrier and go == self.executing_step:
            self.waiting_barrier = False
            self.step_running.set()
            if (go in self.action_map and self.action_map[go] == "CODE1"):
                self.worker_thread = threading.Thread(target=self.execute_code1_step, args=(go,), daemon=True)
            else:
                self.worker_thread = threading.Thread(target=self.execute_step, args=(go,), daemon=True)
            self.worker_thread.start()

    def execute_code1_step(self, step):
        try:
            self.run_code1_feature()
            self.step_done = True
            self.get_logger().info(f"‚úÖ (B) Step {step} (CODE1) ÏôÑÎ£å")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"‚ùå (B) Step {step} (CODE1) Ïã§Ìå®: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def run_code1_feature(self):
        self.get_logger().info("üß© (B) CODE1 Í∞ÑÎã® Ï≤òÎ¶¨ ÏãúÏûë")
        self._wait_if_paused()
        self._ckpt_send_angles(self.BASIC_POSE, self.FAST_SPEED); time.sleep(0.5)
        self._wait_if_paused()
        self._ckpt_set_gripper(100, 40); time.sleep(0.3)
        self.get_logger().info("üß© (B) CODE1 Í∞ÑÎã® Ï≤òÎ¶¨ ÏôÑÎ£å")

    def execute_step(self, step):
        angles = self.action_map[step]
        try:
            self._wait_if_paused()
            self._ckpt_send_angles(angles[:6], 30)
            self._wait_if_paused()
            self._ckpt_set_gripper(angles[6], 30)

            time.sleep(2)
            self.step_done = True
            self.get_logger().info(f"‚úÖ (B) Step {step} ÏôÑÎ£å")
        except Exception as e:
            self.step_done = False
            self.get_logger().error(f"‚ùå (B) Step {step} Ïã§Ìå®: {e}")
        finally:
            self.step_running.clear()
            self.done_pub.publish(Int32(data=int(step)))
            self.executing_step = None
            if self.pending_step is not None:
                nxt = self.pending_step; self.pending_step = None
                self.step_callback(Int32(data=nxt))

    def tick_timeout(self):
        if self.waiting_barrier and self.executing_step is not None:
            if time.time() - self.last_step_time > 3.0:
                self.ready_pub.publish(Int32(data=int(self.executing_step)))
                self.last_step_time = time.time()
                self.get_logger().warn(f"‚è≥ (B) READY Ïû¨Ï†ÑÏÜ°: {self.executing_step}")

def main(args=None):
    rclpy.init(args=args)
    node = RobotB1Node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
