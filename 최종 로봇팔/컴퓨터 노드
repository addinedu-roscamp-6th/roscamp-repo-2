import time
import threading

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32, Bool

class CoordinatorNode(Node):
    def __init__(self):
        super().__init__('coordinator_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # 상태
        self.current_step = None
        self.step_list = []
        self.idx = 0

        # READY/DONE 상태
        self.a_ready = -1
        self.b_ready = -1
        self.a_done = -1
        self.b_done = -1
        self.waiting_ready = False

        # 타임스탬프(재전송)
        self.last_step_sent = 0.0
        self.last_go_sent = 0.0

        # 동시성 보호
        self._lock = threading.Lock()

        # ───── 구독
        self.create_subscription(Int32, '/a_1_done', self.cb_a_done, self.qos1)
        self.create_subscription(Int32, '/b_1_done', self.cb_b_done, self.qos1)
        self.create_subscription(Int32, '/a_ready_step', self.cb_a_ready, self.qos1)
        self.create_subscription(Int32, '/b_ready_step', self.cb_b_ready, self.qos1)

        # GUI/외부 노드용 명령 토픽(1/2/3/4)
        self.create_subscription(Int32, '/coordinator/cmd', self.cb_ui_cmd, self.qos1)

        # ───── 발행
        self.pub_a = self.create_publisher(Int32, '/robot_a_1_node', self.qos1)
        self.pub_b = self.create_publisher(Int32, '/robot_b_1_node', self.qos1)
        self.pub_go = self.create_publisher(Int32, '/go_step', self.qos1)

        # 일시정지/준비자세 제어 토픽
        self.pub_a_pause = self.create_publisher(Bool, '/a_pause', self.qos1)
        self.pub_b_pause = self.create_publisher(Bool, '/b_pause', self.qos1)
        self.pub_a_move_ready = self.create_publisher(Bool, '/a_move_ready', self.qos1)
        self.pub_b_move_ready = self.create_publisher(Bool, '/b_move_ready', self.qos1)

        # 타이머: 재전송/상태 전개
        self.create_timer(0.2, self.tick)

        # 키보드 입력 스레드(ROS 콜백과 분리)
        threading.Thread(target=self.cli_loop, daemon=True).start()

    # ──────────────────────────────── CLI(키보드) 루프
    def cli_loop(self):
        while True:
            # 메뉴: 시퀀스 비활성 상태에서만 노출
            if self.current_step is None and not self.waiting_ready:
                print("\n🌟 기능을 선택하세요:")
                print("  1. 식판 적재 (101~117)")
                print("  2. 식판 회수 (201~214)")
                print("  3. 일시정지(→ 프롬프트에서 3=계속, 4=초기화)")
            try:
                s = input("▶ 번호 입력: ").strip()
            except Exception:
                time.sleep(0.2); continue
            if not s:
                continue
            try:
                n = int(s)
            except ValueError:
                print("⚠️ 숫자를 입력하세요."); continue

            if n == 1:
                self.start_sequence(load=True)
            elif n == 2:
                self.start_sequence(load=False)
            elif n == 3:
                # 실행 중이든 아니든 즉시 일시정지 → 준비자세 → 계속/초기화 질의
                self._send_pause(True)
                self._send_move_ready()
                print("⏸ 일시정지됨. 계속하려면 3, 초기화하려면 4를 입력하세요.")
                while True:
                    try:
                        ans = int(input("▶ 3=계속 / 4=초기화: ").strip())
                    except Exception:
                        print("⚠️ 숫자를 입력하세요."); continue
                    if ans == 3:
                        self._send_pause(False)
                        print("▶ 재개 신호 전송")
                        break
                    elif ans == 4:
                        self._reset_to_menu()
                        print("↺ 초기화 완료. 메뉴로 돌아갑니다.")
                        break
                    else:
                        print("⚠️ 3 또는 4만 입력하세요.")
            else:
                print("⚠️ 1/2/3 중 선택하세요.")

    # ──────────────────────────────── 외부(GUI) 명령 콜백
    def cb_ui_cmd(self, msg: Int32):
        cmd = int(msg.data)
        if cmd == 1:
            self.start_sequence(load=True)
            self.get_logger().info("[UI] 적재 시퀀스 시작")
        elif cmd == 2:
            self.start_sequence(load=False)
            self.get_logger().info("[UI] 회수 시퀀스 시작")
        elif cmd == 3:
            # GUI에서는 3을 '재개'로 사용(일시정지는 /a_pause,/b_pause 사용 권장)
            self._send_pause(False)
            self.get_logger().info("[UI] 재개 신호 전송")
        elif cmd == 4:
            self._reset_to_menu()
            self.get_logger().info("[UI] 초기화 완료(메뉴 대기)")
        else:
            self.get_logger().warn(f"[UI] 알 수 없는 명령: {cmd}")

    # ──────────────────────────────── 시퀀스 제어
    def start_sequence(self, load: bool):
        with self._lock:
            self.step_list = list(range(101, 118)) if load else list(range(201, 215))
            self.idx = 0
        self.start_step()

    def start_step(self):
        with self._lock:
            self.current_step = self.step_list[self.idx]
            self.a_ready = self.b_ready = -1
            self.a_done = self.b_done = -1
            self.waiting_ready = True
        self.send_step()

    def send_step(self):
        msg = Int32(data=int(self.current_step))
        self.pub_a.publish(msg)
        self.pub_b.publish(msg)
        self.last_step_sent = time.time()
        self.get_logger().info(f"📤 STEP {self.current_step} 전송 → A, B")

    # ──────────────────────────────── 콜백
    def cb_a_ready(self, msg): self.a_ready = int(msg.data)
    def cb_b_ready(self, msg): self.b_ready = int(msg.data)

    def cb_a_done(self, msg):
        self.a_done = int(msg.data)
        self.get_logger().info(f"✅ A DONE: {self.a_done}")

    def cb_b_done(self, msg):
        self.b_done = int(msg.data)
        self.get_logger().info(f"✅ B DONE: {self.b_done}")

    # ──────────────────────────────── 메인 루프
    def tick(self):
        if self.current_step is None:
            return

        now = time.time()

        # 1) READY 배리어
        if self.waiting_ready:
            if self.a_ready == self.current_step and self.b_ready == self.current_step:
                self.pub_go.publish(Int32(data=int(self.current_step)))
                self.last_go_sent = now
                self.waiting_ready = False
                self.get_logger().info(f"🚦 GO {self.current_step} 발행(동시 시작)")
                return
            # STEP 재전송(유실 대비)
            if now - self.last_step_sent > 0.5:
                self.send_step()
            return

        # 2) 실행 중 → DONE 대기
        if self.a_done == self.current_step and self.b_done == self.current_step:
            self.get_logger().info(f"🎉 STEP {self.current_step} 모두 완료")
            with self._lock:
                self.idx += 1
                if self.idx >= len(self.step_list):
                    # 시퀀스 종료 → 메뉴 대기 상태로만 전환(입력 스레드가 메뉴 출력)
                    self.get_logger().info("🏁 모든 STEP 완료. 메뉴로 돌아갑니다.")
                    self.current_step = None
                    self.step_list = []
                    self.waiting_ready = False
                else:
                    self.start_step()
            return

        # GO 재전송(유실 대비)
        if now - self.last_go_sent > 0.7:
            self.pub_go.publish(Int32(data=int(self.current_step)))
            self.last_go_sent = now

    # ──────────────────────────────── 유틸(토픽 래퍼)
    def _send_pause(self, flag: bool):
        self.pub_a_pause.publish(Bool(data=bool(flag)))
        self.pub_b_pause.publish(Bool(data=bool(flag)))

    def _send_move_ready(self):
        self.pub_a_move_ready.publish(Bool(data=True))
        self.pub_b_move_ready.publish(Bool(data=True))

    def _reset_to_menu(self):
        # 즉시 일시정지 + 준비자세 지시 후, 상태만 초기화
        self._send_pause(True)
        self._send_move_ready()
        with self._lock:
            self.current_step = None
            self.step_list = []
            self.idx = 0
            self.a_ready = self.b_ready = -1
            self.a_done = self.b_done = -1
            self.waiting_ready = False

def main(args=None):
    rclpy.init(args=args)
    node = CoordinatorNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\n[중단됨]")
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
