import time
import threading

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32, Bool

class CoordinatorNode(Node):
    def __init__(self):
        super().__init__('coordinator_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # ìƒíƒœ
        self.current_step = None
        self.step_list = []
        self.idx = 0

        # READY/DONE ìƒíƒœ
        self.a_ready = -1
        self.b_ready = -1
        self.a_done = -1
        self.b_done = -1
        self.waiting_ready = False

        # íƒ€ì„ìŠ¤íƒ¬í”„(ì¬ì „ì†¡)
        self.last_step_sent = 0.0
        self.last_go_sent = 0.0

        # ë™ì‹œì„± ë³´í˜¸
        self._lock = threading.Lock()

        # â”€â”€â”€â”€â”€ êµ¬ë…
        self.create_subscription(Int32, '/a_1_done', self.cb_a_done, self.qos1)
        self.create_subscription(Int32, '/b_1_done', self.cb_b_done, self.qos1)
        self.create_subscription(Int32, '/a_ready_step', self.cb_a_ready, self.qos1)
        self.create_subscription(Int32, '/b_ready_step', self.cb_b_ready, self.qos1)

        # GUI/ì™¸ë¶€ ë…¸ë“œìš© ëª…ë ¹ í† í”½(1/2/3/4)
        self.create_subscription(Int32, '/coordinator/cmd', self.cb_ui_cmd, self.qos1)

        # â”€â”€â”€â”€â”€ ë°œí–‰
        self.pub_a = self.create_publisher(Int32, '/robot_a_1_node', self.qos1)
        self.pub_b = self.create_publisher(Int32, '/robot_b_1_node', self.qos1)
        self.pub_go = self.create_publisher(Int32, '/go_step', self.qos1)

        # ì¼ì‹œì •ì§€/ì¤€ë¹„ìì„¸ ì œì–´ í† í”½
        self.pub_a_pause = self.create_publisher(Bool, '/a_pause', self.qos1)
        self.pub_b_pause = self.create_publisher(Bool, '/b_pause', self.qos1)
        self.pub_a_move_ready = self.create_publisher(Bool, '/a_move_ready', self.qos1)
        self.pub_b_move_ready = self.create_publisher(Bool, '/b_move_ready', self.qos1)

        # íƒ€ì´ë¨¸: ì¬ì „ì†¡/ìƒíƒœ ì „ê°œ
        self.create_timer(0.2, self.tick)

        # í‚¤ë³´ë“œ ì…ë ¥ ìŠ¤ë ˆë“œ(ROS ì½œë°±ê³¼ ë¶„ë¦¬)
        threading.Thread(target=self.cli_loop, daemon=True).start()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLI(í‚¤ë³´ë“œ) ë£¨í”„
    def cli_loop(self):
        while True:
            # ë©”ë‰´: ì‹œí€€ìŠ¤ ë¹„í™œì„± ìƒíƒœì—ì„œë§Œ ë…¸ì¶œ
            if self.current_step is None and not self.waiting_ready:
                print("\nğŸŒŸ ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš”:")
                print("  1. ì‹íŒ ì ì¬ (101~117)")
                print("  2. ì‹íŒ íšŒìˆ˜ (201~214)")
                print("  3. ì¼ì‹œì •ì§€(â†’ í”„ë¡¬í”„íŠ¸ì—ì„œ 3=ê³„ì†, 4=ì´ˆê¸°í™”)")
            try:
                s = input("â–¶ ë²ˆí˜¸ ì…ë ¥: ").strip()
            except Exception:
                time.sleep(0.2); continue
            if not s:
                continue
            try:
                n = int(s)
            except ValueError:
                print("âš ï¸ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”."); continue

            if n == 1:
                self.start_sequence(load=True)
            elif n == 2:
                self.start_sequence(load=False)
            elif n == 3:
                # ì‹¤í–‰ ì¤‘ì´ë“  ì•„ë‹ˆë“  ì¦‰ì‹œ ì¼ì‹œì •ì§€ â†’ ì¤€ë¹„ìì„¸ â†’ ê³„ì†/ì´ˆê¸°í™” ì§ˆì˜
                self._send_pause(True)
                self._send_move_ready()
                print("â¸ ì¼ì‹œì •ì§€ë¨. ê³„ì†í•˜ë ¤ë©´ 3, ì´ˆê¸°í™”í•˜ë ¤ë©´ 4ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
                while True:
                    try:
                        ans = int(input("â–¶ 3=ê³„ì† / 4=ì´ˆê¸°í™”: ").strip())
                    except Exception:
                        print("âš ï¸ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”."); continue
                    if ans == 3:
                        self._send_pause(False)
                        print("â–¶ ì¬ê°œ ì‹ í˜¸ ì „ì†¡")
                        break
                    elif ans == 4:
                        self._reset_to_menu()
                        print("â†º ì´ˆê¸°í™” ì™„ë£Œ. ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.")
                        break
                    else:
                        print("âš ï¸ 3 ë˜ëŠ” 4ë§Œ ì…ë ¥í•˜ì„¸ìš”.")
            else:
                print("âš ï¸ 1/2/3 ì¤‘ ì„ íƒí•˜ì„¸ìš”.")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì™¸ë¶€(GUI) ëª…ë ¹ ì½œë°±
    def cb_ui_cmd(self, msg: Int32):
        cmd = int(msg.data)
        if cmd == 1:
            self.start_sequence(load=True)
            self.get_logger().info("[UI] ì ì¬ ì‹œí€€ìŠ¤ ì‹œì‘")
        elif cmd == 2:
            self.start_sequence(load=False)
            self.get_logger().info("[UI] íšŒìˆ˜ ì‹œí€€ìŠ¤ ì‹œì‘")
        elif cmd == 3:
            # GUIì—ì„œëŠ” 3ì„ 'ì¬ê°œ'ë¡œ ì‚¬ìš©(ì¼ì‹œì •ì§€ëŠ” /a_pause,/b_pause ì‚¬ìš© ê¶Œì¥)
            self._send_pause(False)
            self.get_logger().info("[UI] ì¬ê°œ ì‹ í˜¸ ì „ì†¡")
        elif cmd == 4:
            self._reset_to_menu()
            self.get_logger().info("[UI] ì´ˆê¸°í™” ì™„ë£Œ(ë©”ë‰´ ëŒ€ê¸°)")
        else:
            self.get_logger().warn(f"[UI] ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹: {cmd}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì‹œí€€ìŠ¤ ì œì–´
    def start_sequence(self, load: bool):
        with self._lock:
            self.step_list = list(range(101, 118)) if load else list(range(201, 215))
            self.idx = 0
        self.start_step()

    def start_step(self):
        with self._lock:
            self.current_step = self.step_list[self.idx]
            self.a_ready = self.b_ready = -1
            self.a_done = self.b_done = -1
            self.waiting_ready = True
        self.send_step()

    def send_step(self):
        msg = Int32(data=int(self.current_step))
        self.pub_a.publish(msg)
        self.pub_b.publish(msg)
        self.last_step_sent = time.time()
        self.get_logger().info(f"ğŸ“¤ STEP {self.current_step} ì „ì†¡ â†’ A, B")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì½œë°±
    def cb_a_ready(self, msg): self.a_ready = int(msg.data)
    def cb_b_ready(self, msg): self.b_ready = int(msg.data)

    def cb_a_done(self, msg):
        self.a_done = int(msg.data)
        self.get_logger().info(f"âœ… A DONE: {self.a_done}")

    def cb_b_done(self, msg):
        self.b_done = int(msg.data)
        self.get_logger().info(f"âœ… B DONE: {self.b_done}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ ë£¨í”„
    def tick(self):
        if self.current_step is None:
            return

        now = time.time()

        # 1) READY ë°°ë¦¬ì–´
        if self.waiting_ready:
            if self.a_ready == self.current_step and self.b_ready == self.current_step:
                self.pub_go.publish(Int32(data=int(self.current_step)))
                self.last_go_sent = now
                self.waiting_ready = False
                self.get_logger().info(f"ğŸš¦ GO {self.current_step} ë°œí–‰(ë™ì‹œ ì‹œì‘)")
                return
            # STEP ì¬ì „ì†¡(ìœ ì‹¤ ëŒ€ë¹„)
            if now - self.last_step_sent > 0.5:
                self.send_step()
            return

        # 2) ì‹¤í–‰ ì¤‘ â†’ DONE ëŒ€ê¸°
        if self.a_done == self.current_step and self.b_done == self.current_step:
            self.get_logger().info(f"ğŸ‰ STEP {self.current_step} ëª¨ë‘ ì™„ë£Œ")
            with self._lock:
                self.idx += 1
                if self.idx >= len(self.step_list):
                    # ì‹œí€€ìŠ¤ ì¢…ë£Œ â†’ ë©”ë‰´ ëŒ€ê¸° ìƒíƒœë¡œë§Œ ì „í™˜(ì…ë ¥ ìŠ¤ë ˆë“œê°€ ë©”ë‰´ ì¶œë ¥)
                    self.get_logger().info("ğŸ ëª¨ë“  STEP ì™„ë£Œ. ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.")
                    self.current_step = None
                    self.step_list = []
                    self.waiting_ready = False
                else:
                    self.start_step()
            return

        # GO ì¬ì „ì†¡(ìœ ì‹¤ ëŒ€ë¹„)
        if now - self.last_go_sent > 0.7:
            self.pub_go.publish(Int32(data=int(self.current_step)))
            self.last_go_sent = now

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìœ í‹¸(í† í”½ ë˜í¼)
    def _send_pause(self, flag: bool):
        self.pub_a_pause.publish(Bool(data=bool(flag)))
        self.pub_b_pause.publish(Bool(data=bool(flag)))

    def _send_move_ready(self):
        self.pub_a_move_ready.publish(Bool(data=True))
        self.pub_b_move_ready.publish(Bool(data=True))

    def _reset_to_menu(self):
        # ì¦‰ì‹œ ì¼ì‹œì •ì§€ + ì¤€ë¹„ìì„¸ ì§€ì‹œ í›„, ìƒíƒœë§Œ ì´ˆê¸°í™”
        self._send_pause(True)
        self._send_move_ready()
        with self._lock:
            self.current_step = None
            self.step_list = []
            self.idx = 0
            self.a_ready = self.b_ready = -1
            self.a_done = self.b_done = -1
            self.waiting_ready = False

def main(args=None):
    rclpy.init(args=args)
    node = CoordinatorNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\n[ì¤‘ë‹¨ë¨]")
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
