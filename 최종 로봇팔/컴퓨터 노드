import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from std_msgs.msg import Int32, Bool
import time

class CoordinatorNode(Node):
    def __init__(self):
        super().__init__('coordinator_node')

        # QoS
        self.qos1 = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # ÏÉÅÌÉú
        self.current_step = None
        self.step_list = []
        self.idx = 0

        # READY/DONE ÏÉÅÌÉú
        self.a_ready = -1
        self.b_ready = -1
        self.a_done = -1
        self.b_done = -1
        self.waiting_ready = False

        # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ (Ïû¨Ï†ÑÏÜ°)
        self.last_step_sent = 0.0
        self.last_go_sent = 0.0

        # Íµ¨ÎèÖ
        self.create_subscription(Int32, '/a_1_done', self.cb_a_done, self.qos1)
        self.create_subscription(Int32, '/b_1_done', self.cb_b_done, self.qos1)
        self.create_subscription(Int32, '/a_ready_step', self.cb_a_ready, self.qos1)
        self.create_subscription(Int32, '/b_ready_step', self.cb_b_ready, self.qos1)

        # Î∞úÌñâ
        self.pub_a = self.create_publisher(Int32, '/robot_a_1_node', self.qos1)
        self.pub_b = self.create_publisher(Int32, '/robot_b_1_node', self.qos1)
        self.pub_go = self.create_publisher(Int32, '/go_step', self.qos1)

        # ÌÉÄÏù¥Î®∏: Ïû¨Ï†ÑÏÜ°/ÏÉÅÌÉú Ï†ÑÍ∞ú
        self.create_timer(0.2, self.tick)

        # Î©îÎâ¥
        self.choose_function()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def choose_function(self):
        print("\nüåü Í∏∞Îä•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:")
        print("  1. ÏãùÌåê Ï†ÅÏû¨ (101~113)")
        print("  2. ÏãùÌåê ÌöåÏàò (201~210)")
        while True:
            try:
                option = int(input("‚ñ∂ Í∏∞Îä• Î≤àÌò∏ ÏûÖÎ†•: "))
                if option == 1:
                    # 113 Ìè¨Ìï®
                    self.step_list = list(range(101, 118))
                    break
                elif option == 2:
                    # 210 Ìè¨Ìï®
                    self.step_list = list(range(201, 215))
                    break
                else:
                    print("‚ö†Ô∏è 1 ÎòêÎäî 2Îßå ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
            except Exception:
                print("‚ö†Ô∏è Ïà´ÏûêÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")

        self.idx = 0
        self.start_step()

    def start_step(self):
        self.current_step = self.step_list[self.idx]
        self.a_ready = self.b_ready = -1
        self.a_done  = self.b_done  = -1
        self.waiting_ready = True
        self.send_step()

    def send_step(self):
        msg = Int32(data=int(self.current_step))
        self.pub_a.publish(msg)
        self.pub_b.publish(msg)
        self.last_step_sent = time.time()
        self.get_logger().info(f"üì§ STEP {self.current_step} Ï†ÑÏÜ° ‚Üí A, B")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # ÏΩúÎ∞±
    def cb_a_ready(self, msg):
        self.a_ready = int(msg.data)

    def cb_b_ready(self, msg):
        self.b_ready = int(msg.data)

    def cb_a_done(self, msg):
        self.a_done = int(msg.data)
        self.get_logger().info(f"‚úÖ A DONE: {self.a_done}")

    def cb_b_done(self, msg):
        self.b_done = int(msg.data)
        self.get_logger().info(f"‚úÖ B DONE: {self.b_done}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Î©îÏù∏ Î£®ÌîÑ(Ïû¨Ï†ÑÏÜ°/Ï†ÑÍ∞ú)
    def tick(self):
        if self.current_step is None:
            return

        now = time.time()

        # 1) READY Î∞∞Î¶¨Ïñ¥
        if self.waiting_ready:
            # Îëò Îã§ ÌòÑÏû¨ stepÏóê ÎåÄÌï¥ READY ÎêòÏóàÏúºÎ©¥ GO Î∞úÌñâ
            if self.a_ready == self.current_step and self.b_ready == self.current_step:
                self.pub_go.publish(Int32(data=int(self.current_step)))
                self.last_go_sent = now
                self.waiting_ready = False
                self.get_logger().info(f"üö¶ GO {self.current_step} Î∞úÌñâ(ÎèôÏãú ÏãúÏûë)")
                return

            # STEP Ïû¨Ï†ÑÏÜ° (Ïú†Ïã§ ÎåÄÎπÑ)
            if now - self.last_step_sent > 0.5:
                self.send_step()
            return

        # 2) Ïã§Ìñâ Ï§ë ‚Üí DONE ÎåÄÍ∏∞
        if self.a_done == self.current_step and self.b_done == self.current_step:
            self.get_logger().info(f"üéâ STEP {self.current_step} Î™®Îëê ÏôÑÎ£å")
            self.idx += 1
            if self.idx >= len(self.step_list):
                self.get_logger().info("üèÅ Î™®Îì† STEP ÏôÑÎ£å. Í∏∞Îä• ÏÑ†ÌÉùÏúºÎ°ú ÎèåÏïÑÍ∞ëÎãàÎã§.")
                self.current_step = None
                time.sleep(0.5)
                self.choose_function()
            else:
                self.start_step()
            return

        # GO Ïû¨Ï†ÑÏÜ° (Ïú†Ïã§ ÎåÄÎπÑ)
        if now - self.last_go_sent > 0.7:
            self.pub_go.publish(Int32(data=int(self.current_step)))
            self.last_go_sent = now

def main(args=None):
    rclpy.init(args=args)
    node = CoordinatorNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\n[Ï§ëÎã®Îê®]")
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
